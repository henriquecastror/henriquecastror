---
title: 'Empirical Methods in Finance'
subtitle: 'Part 4'
author: 'Henrique C. Martins'
format:
  revealjs: 
    slide-number: true
    theme: simple
    chalkboard: true
    preview-links: auto
    logo: figs/background8.png
    css: logo.css
    footer: '**[**Henrique C. Martins**] [[henrique.martins@fgv.br](mailto:henrique.martins@fgv.br)][Do not use without permission]**  '
    multiplex: true
    scrollable: true 
title-slide-attributes:
    data-background-color: "#b1cafa"
include-after: |
  <script type="text/javascript">
    Reveal.on('ready', event => {
      if (event.indexh === 0) {
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
    });
    Reveal.addEventListener('slidechanged', (event) => {
      if (event.indexh === 0) {
        Reveal.configure({ slideNumber: null });
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
      if (event.indexh === 1) { 
        Reveal.configure({ slideNumber: 'c' });
        document.querySelector("div.has-logo > img.slide-logo").style.display = null;
      }
    });
  </script>

---



```{r setup}
#| include: false
#| warning: false


# library(reticulate)
# use_python("C:/Users/hcmrt/AppData/Local/Programs/Python/Python310/python.exe")
library(reticulate)
library(Statamarkdown)
#reticulate::py_install("matplotlib")
#reticulate::py_install("seaborn")
#reticulate::py_install("pyfinance")
#reticulate::py_install("xlrd")
#reticulate::py_install("quandl")

```






# More about Regressions {.smaller background="#454343"}

## Regression {.smaller background="#454343"}

Linear regressions are the workhorse tool in econometrics

-   **Simplicity**: straightforward to understand, implement, and visualize.

. . .

-   **Interpretability**: coefficients have clear interpretations.
    -   represents the change in the Y for a one-unit change in the X, holding all other variables constant.

. . .

-   **Versatility**: simple linear regression or *multiple linear regression*.

. . .

-   **Assumptions**: linearity, independence of errors, homoscedasticity, and normality of errors.

. . .

-   **Baseline Model**: You can compare the performance of more advanced models to linear regression.

. . .

-   **Estimation**: provides clear estimates of the coefficients' confidence intervals and hypothesis testing.






## Regression {.smaller background="#454343"}

In this setting, the variables $y$ and $x$ can have several names.

| Y                  | X                    |
|--------------------|----------------------|
| Dependent variable | Independent variable |
| Explained variable | Explanatory variable |
| Response variable  | Control variable     |
| Predicted variable | Predictor variable   |
| Regressand         | Regressor            |















## Regression {.smaller background="#454343"}

Broadly, we are interested in how y is explained by x?

-   $y_i = \alpha + \beta_1 x_i + \epsilon$

. . .

Perhaps $\epsilon$ is the most important part of a regression.

The interpretation is "*everything that is not explained by X and that explains Y*".

. . .

A comment

-   Usually, the literature uses $\epsilon$ for the "estimated" residual.

-   And $\mu$ for the "true" residual, which necessarily implies that the assumptions hold.

-   At the end od the day, you don't need to worry to much with the notation of this term because we are always in the "estimated world", and almost never in the "true world".

-   The "true world" implies that you are studying the population or that you have a true random sample of the population

    -   $y_i = \alpha + \beta_1 x_i + \mu$




## Regression {.smaller background="#454343"}

**Remember**

- $y, x$, and $\mu$ are random variables
- $y and x$ are observable
- $\mu$ and $\beta$ are unobservable
- $\mu$ captures everything that determines y after accounting for x 

Our goal is to estimate Œ≤





## Regression {.smaller background="#454343"}

There are some assumptions/requirements about $\mu$ in a OLS

**First assumption**

-   E($\mu$) = 0

    -   This is a simple assumption, not strong at all.
    -   It simply assumes that the average of $\mu$ is zero in the population.
    -   Basically, any non-zero mean is absorbed by the intercept
        -   Say that E($\mu$) = k
        -   We could rewrite $\mu = k + w$, where E(w)=0
        -   Then, model becomes $y=(\alpha +ùëò) + \betaùë•+ùë§$
        -   Intercept is now just (Œ± + k), and error, w, is mean zero






## Regression {.smaller background="#454343"}

**Second assumption**

-   E($\mu$\|x) = E($\mu$) for all values of x
    -   It says that the average value of $\mu$ does not depend on the value of x (i.e., the slice of the population you are looking at).
    -   We say that $\mu$ is mean-independent of x.
    -   This is true if the X and the $\mu$ are independent to each other.
    -   Implies that x and $\mu$ are *uncorrelated*.
    -   **Conditional Mean Independence (CMI)**.
    -   This is one of the keys assumption to *causal inference*.






## Regression {.smaller background="#454343"}

**Second assumption**

**Example**

Let's say the model is:

$$wage = \alpha + \beta Schooling_{years} + \epsilon$$

-   where $\epsilon$ represents *unobserved ability*.

Does CMI hold?

That is E(ability\|x=8)=E(ability\|x=10)=E(ability\|x=12)?

. . .

**Probably not**, because the unobserved ability should depend on the years of schooling.

The solution (not trivial) would be to include ability as a new X.






## Regression {.smaller background="#454343"}

**Another example**

Consider the following model (with only one X)

$$Leverage_i = \alpha + \beta_1 Profitability_i + \mu_i$$

-   CMI says that, to every firm *i*, $\mu$ is the same, even when firms have different profitability.

-   Can you think on examples when this assumption may not hold in this model?

. . .

1)  unprofitable firms have higher bankruptcy risk, which should make them to have lower leverage (tradeoff theory).

2)  unprofitable firms have low cash, which should make them to have more leverage (pecking order theory).




## Regression {.smaller background="#454343"}

**The discussion of whether the CMI holds is the origin of the "endogeneity" problem.**

You will face reviewers arguing reasons of why the CMI might not hold in your case.

- Many  will criticize a model by saying it has an ‚Äúendogeneity problem‚Äù, whithout explaining more.

  - This is very generic. **Don't do that!**

. . .

They should explain what is the source of the problem that is making the model violate CMI.

 - OVB, selection bias, reverse causality, simultaneity, etc?

. . . 

Generally speaking, endogeneity refers to a violation of CMI, meaning that $x$ and $\mu$ are correlated.

This is always a plausible possibility, since $\mu$ carries a lot of stuff (something must be correlated with X).





## Regression {.smaller background="#454343"}

**Third assumption**

Combining 1 and 2 leads to

-   E($\mu$\|x) = 0
    -   This is a very important assumption called **zero conditional mean assumption**.

## Ordinary Least Squares {.smaller background="#454343"}

Our focus is to find estimates for $\alpha$ and $\beta$. Should we have access to the population, it would be easy. We could write:

$$y_i= \alpha + \beta_1x_i + \mu$$

. . .

But remember that,

$$E(u) = 0$$ $$E(u|x) = 0$$

The second bullet implies that the correlation between x and $\mu$ is zero (we can write that as E(x,u) = 0).

. . .

::: callout-important
Remember: $\alpha$ and $\beta$ are parameters to be estimated (i.e., constants), while $X$ and $Y$ are variables
:::








## Regression {.smaller background="#454343"}

So we can write that (in the **population**)

$E(y - \alpha - \beta_1x ) = 0$

$(x[y - \alpha - \beta_1x ]) = 0$

. . .

So we can write that (in the **sample**)

$\frac{1}{n} \sum_{i=1}^n (y_i - \hat{\alpha} - \hat{\beta_1} x_i ) = 0$ , We will use this to find $\alpha$:

$\frac{1}{n} \sum_{i=1}^n (x_i [y_i - \hat{\alpha} - \hat{\beta_1} x_i ]) = 0$ , We will use this to find $\beta$:







## Finding $\alpha$ {.smaller background="#454343"}

From before:

$$\frac{1}{n} \sum_{i=1}^n (y_i - \hat{\alpha} - \hat{\beta_1} x_i ) =0$$

. . .

Passing the sum operator through

$$\frac{1}{n}\sum_{i=1}^n(y_i) - \frac{1}{n}\sum_{i=1}^n(\hat{\alpha})  - \frac{1}{n} \sum_{i=1}^n(\hat{\beta_1} x_i )=0$$

. . .

Coefficients are constants, so we can get rid of the sum operator.

$$\frac{1}{n}\sum_{i=1}^n(y_i) - \hat{\alpha}  - \hat{\beta_1} \frac{1}{n}  \sum_{i=1}^n(\ x_i )=0$$








## Finding $\alpha$ {.smaller background="#454343"}

-   We know that $\frac{1}{n}\sum_{i=1}^n(y_i)$ is $\bar{y_i}$ (the mean)

$$\bar{y_i} - \hat{\alpha}  - \hat{\beta_1}  \bar{x_i}=0$$

. . .

So we write:

$$\hat{\alpha}  = \bar{y_i} -  \hat{\beta_1}   \bar{x_i}$$

. . .

**Easy Peasy** üòÄ





## Finding $\beta$ {.smaller background="#454343"}

From before:

$$\frac{1}{n} \sum_{i=1}^n (x_i [y_i - \hat{\alpha} - \hat{\beta_1} x_i ]) = 0$$

. . .

But now we have:

$$\hat{\alpha}  = \bar{y_i} -  \hat{\beta_1}   \bar{x_i}$$

. . .

Thus,

$$\frac{1}{n} \sum_{i=1}^n (x_i [y_i - (\bar{y_i} -  \hat{\beta_1}   \bar{x_i}) - \hat{\beta_1} x_i ]) = 0$$




## Finding $\beta$ {.smaller background="#454343"}

Turning into

$$\frac{1}{n} \sum_{i=1}^n (x_i [y_i - \bar{y_i} ])  -  \frac{1}{n} \sum_{i=1}^n (x_i [\hat{\beta_1} x_i - \hat{\beta_1} \bar{x_i} ]) = 0$$

. . .

Or

$$\frac{1}{n} \sum_{i=1}^n (x_i [y_i - \bar{y_i} ])  =  \hat{\beta_1} \frac{1}{n} \sum_{i=1}^n (x_i [ x_i  - \bar{x_i} ]) $$

. . . 

Last step (I am skipping some steps here)

$$\frac{1}{n} \sum_{i=1}^n (x_i - \bar{x} )(y_i - \bar{y_i} )  =  \hat{\beta_1} \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x_i} )^2 $$




## Finding $\beta$ {.smaller background="#454343"}


If the variance of x is not zero, we can write $\beta$ as

$$\hat{\beta_1} = \frac{\sum_i^n (x_i - \bar{x})(y_i - \bar{y})}{\sum_i^n (x_i - \bar{x})^2} = \frac{Covariance(x_i,y_i)}{Variance(x_i)}$$



## Finding $\mu$  {.smaller background="#454343"}

Now that we have $\hat{Y_i}=\hat{\alpha} + \hat{\beta_1} X_i$, we can estimate the residual $\mu$

$$\hat{\mu} = Y_i - \hat{Y_i}$$


Which is the same as:

$$\hat{\mu} = Y_i - \hat{\alpha} - \hat{\beta_1}x_i$$

Most residuals will not be 0, meaning they do not lie on the best fitting line. 






## Finding $\mu$  {.smaller background="#454343"}

The job of an OLS model is find the parameters to minimize the squared error (i.e., to find the best fitting line).

$$\sum_{i=1}^n \hat{\mu}^2 = \sum_{i=1}^n(Y_i - \hat{Y_i})^2$$












## Regression ([Source](https://mixtape.scunning.com/02-probability_and_regression#ordinary-least-squares)) {.smaller background="#454343"}

Another example of regression. The differences in the coefficients are due to the differences in the seed of the random variables generator.


::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(tidyverse)
set.seed(1)
tb <- tibble(
  x = rnorm(10000),
  u = rnorm(10000),
  y = 5.5*x + 12*u # notice that I am defining the beta1 here. The 5.5 is the "true" beta we want to estimate.
) 
reg_tb <- lm(y ~ x, data=tb) 
summary(reg_tb)
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
np.random.seed(1)

obs = 10000
data = pd.DataFrame({
    'x': np.random.normal(size=obs),
    'u': np.random.normal(size=obs),
})
data['y'] = 5.5 * data['x'] + 12 * data['u']

X = sm.add_constant(data['x'])
model = sm.OLS(data['y'], X).fit()

print(model.summary())

```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
set seed 1 
set obs 10000 
gen x = rnormal() 
gen u  = rnormal() 
gen y  = 5.5*x + 12*u 
reg y x 
```
:::






## Regression ([Source](https://mixtape.scunning.com/02-probability_and_regression#ordinary-least-squares)) {.smaller background="#454343"}

Another example of regression. The differences in the coefficients are due to the differences in the seed of the random variables generator.

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(tidyverse)
set.seed(1)
tb <- tibble(
  x = rnorm(10000),
  u = rnorm(10000),
  y = 5.5*x + 12*u # notice that I am defining the beta1 here. The 5.5 is the "true" beta we want to estimate.
) 
reg_tb <- lm(y ~ x, data=tb) 
tb %>% 
  lm(y ~ x, .) %>% 
  ggplot(aes(x=x, y=y)) + 
  ggtitle("OLS Regression Line") +
  geom_point(size = 0.05, color = "black", alpha = 0.5) +
  geom_smooth(method = lm, color = "black") +
  annotate("text", x = -1.5, y = 30, color = "red", 
           label = paste("Intercept = ", reg_tb$coefficients[1])) +
  annotate("text", x = 1.5, y = -30, color = "blue", 
           label = paste("Slope =", reg_tb$coefficients[2]))
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
import seaborn as sns
import matplotlib.pyplot as plt

# Create a scatterplot with the OLS regression line using Seaborn
sns.set(style='whitegrid')
plt.figure(figsize=(7, 5))
sns.scatterplot(x='x', y='y', data=data, color='black', alpha=0.5, s=5)
sns.regplot(x='x', y='y', data=data, color='black', scatter=False, line_kws={'color':'black'})
plt.title('OLS Regression Line')
plt.annotate(f'Intercept = {model.params[0]:.2f}', xy=(-1.5, 30), color='red')
plt.annotate(f'Slope = {model.params[1]:.2f}', xy=(1.5, -30), color='blue')
plt.show()

```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: false
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
set seed 1 
set obs 10000 
gen x = rnormal() 
gen u  = rnormal() 
gen y  = 5.5*x + 12*u 
reg y x 
predict yhat1 
gen yhat2 = -0.0750109  + 5.598296*x 
predict uhat1, residual 
gen uhat2=y-yhat2 
qui sum uhat* 
twoway (lfit y x, lcolor(black) lwidth(medium)) (scatter y x, mcolor(black) msize(tiny) msymbol(point)), title(OLS Regression Line) 
qui graph export "files/graph3.svg", replace
```  

![](files/graph3.svg) 

:::






## Regression ([Source](https://mixtape.scunning.com/02-probability_and_regression#ordinary-least-squares)) {.smaller background="#454343"}

Using the previous regressions, we can show  that:

1)  $\hat{y_i} = \hat{\alpha} + \hat{\beta_1} x_i$

2)  $\hat{\mu_i} = y_i - \hat{y_i}$

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true

library(tidyverse)
set.seed(1)
tb <- tibble(
  x = rnorm(10000),
  u = rnorm(10000),
  y = 5.5*x + 12*u # notice that I am defining the beta1 here. The 5.5 is the "true" beta we want to estimate.
) 
reg_tb <- lm(y ~ x, data=tb) 

tb <- tb %>% 
  mutate(
    yhat1 = predict(lm(y ~ x, .)),
    yhat2 = reg_tb$coefficients[1] + reg_tb$coefficients[2]*x, 
    uhat1 = residuals(lm(y ~ x, .)),
    uhat2 = y - yhat2
  )
summary(tb[-1:-3])
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
np.random.seed(1)
obs = 10000
x = np.random.normal(size=obs)
u = np.random.normal(size=obs)
y = 5.5 * x + 12 * u

X = sm.add_constant(x)
model = sm.OLS(y, X).fit()

tb = pd.DataFrame({'x': x, 'u': u, 'y': y})
tb['yhat1'] = model.predict(X)
tb['uhat1'] = y - tb['yhat1']
tb['yhat2'] = model.params[0] + model.params[1] * x
tb['uhat2'] = y - tb['yhat2']

print(tb[['yhat1','yhat2', 'uhat1','uhat2']].describe())
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
set seed 1 
clear 
qui set obs 10000 
gen x = rnormal() 
gen u  = rnormal() 
gen y  = 5.5*x + 12*u 
qui reg y x 
predict uhat1, residual 
predict yhat1 
gen yhat2 = -0.0750109  + 5.598296*x 
gen uhat2=y-yhat2 
sum yhat*  uhat* 
```
:::











# Properties of OLS {.smaller background="#bfc4d9"}


## Properties of OLS {.smaller background="#bfc4d9"}

We can easily show that (remember from before) 

$$\sum_i^n(y_i - \hat{\alpha} - \hat{\beta_1} x_i) = 0$$

And that 

$$\sum_i^n \hat{\mu}  = 0$$

The graphs next slide shows a spherical figure, suggesting that the residual is not correlated with the the fitted values ($\hat{y_i}$)







## Properties of OLS {.smaller background="#bfc4d9"}

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(tidyverse)
set.seed(1)
tb <- tibble(
  x = rnorm(10000),
  u = rnorm(10000),
  y = 5.5*x + 12*u # notice that I am defining the beta1 here. The 5.5 is the "true" beta we want to estimate.
) 
reg_tb <- lm(y ~ x, data=tb) 
tb <- tb %>% 
  mutate(
    yhat1 = predict(lm(y ~ x, .)),
    yhat2 = reg_tb$coefficients[1] + reg_tb$coefficients[2]*x, 
    uhat1 = residuals(lm(y ~ x, .)),
    uhat2 = y - yhat2
  )
tb %>% 
  lm(uhat1 ~ yhat1 , .) %>% 
  ggplot(aes(x=yhat1, y=uhat1)) + 
  geom_point(size = 0.1, color = "black") +
  geom_smooth(method = lm, color = "black")
```



### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
np.random.seed(1)
obs = 10000
x = np.random.normal(size=obs)
u = np.random.normal(size=obs)
y = 5.5 * x + 12 * u

X = sm.add_constant(x)
model = sm.OLS(y, X).fit()

tb = pd.DataFrame({'x': x, 'u': u, 'y': y})
tb['yhat1'] = model.predict(X)
tb['uhat1'] = y - tb['yhat1']
tb['yhat2'] = model.params[0] + model.params[1] * x
tb['uhat2'] = y - tb['yhat2']
model = sm.OLS(tb['uhat1'], sm.add_constant(tb['yhat1'])).fit()
# Create a scatter plot with a regression line
sns.set(style="whitegrid")
plt.figure(figsize=(7, 4.5))
sns.scatterplot(x='yhat1', y='uhat1', data=tb, size=0.05, color='black', alpha=0.5)
sns.regplot(x='yhat1', y='uhat1', data=tb, scatter=False, color='black')
plt.xlabel('yhat1')
plt.ylabel('uhat1')
plt.title('Scatter Plot of uhat1 vs. yhat1')
plt.show()
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: false
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
set seed 1 
set obs 10000 
gen x = rnormal() 
gen u  = rnormal() 
gen y  = 5.5*x + 12*u 
qui reg y x 
predict yhat1 
predict uhat1, residual 
twoway (lfit uhat1 yhat1 , lcolor(black) lwidth(large)) (scatter uhat1 yhat1 , mcolor(black)  msymbol(point))
qui graph export "files/graph4.svg", replace
```  

![](files/graph4.svg) 

:::










## Properties of OLS {.smaller background="#bfc4d9"}

Similarly, we can easily show that 

$$\sum_i^nx_i(y_i - \hat{\alpha} - \hat{\beta_1} x_i) = 0$$
 
And that
 
$$\sum_i^nx_i\hat{\mu}  = 0$$

 
Meaning that the sample covariance between the X and the residual will be always zero.









## Properties of OLS {.smaller background="#bfc4d9"}

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(tidyverse)
set.seed(1)
tb <- tibble(
  x = rnorm(10000),
  u = rnorm(10000),
  y = 5.5*x + 12*u # notice that I am defining the beta1 here. The 5.5 is the "true" beta we want to estimate.
) 
reg_tb <- lm(y ~ x, data=tb) 
tb <- tb %>% 
  mutate(
    yhat1 = predict(lm(y ~ x, .)),
    yhat2 = reg_tb$coefficients[1] + reg_tb$coefficients[2]*x, 
    uhat1 = residuals(lm(y ~ x, .)),
    uhat2 = y - yhat2
  )
tb %>% 
  lm(uhat1 ~ x , .) %>% 
  ggplot(aes(x=x, y=uhat1)) + 
  geom_point(size = 0.1, color = "black") +
  geom_smooth(method = lm, color = "black")
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
np.random.seed(1)
obs = 10000
x = np.random.normal(size=obs)
u = np.random.normal(size=obs)
y = 5.5 * x + 12 * u

X = sm.add_constant(x)
model = sm.OLS(y, X).fit()

tb = pd.DataFrame({'x': x, 'u': u, 'y': y})
tb['yhat1'] = model.predict(X)
tb['uhat1'] = y - tb['yhat1']
tb['yhat2'] = model.params[0] + model.params[1] * x
tb['uhat2'] = y - tb['yhat2']
model = sm.OLS(tb['uhat1'], sm.add_constant(tb['yhat1'])).fit()
# Create a scatter plot with a regression line
sns.set(style="whitegrid")
plt.figure(figsize=(7, 4.5))
sns.scatterplot(x='x', y='uhat1', data=tb, size=0.05, color='black', alpha=0.5)
sns.regplot(x='x', y='uhat1', data=tb, scatter=False, color='black')
plt.xlabel('x')
plt.ylabel('uhat1')
plt.title('Scatter Plot of uhat1 vs. x')
plt.show()
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: false
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
set seed 1 
set obs 10000 
gen x = rnormal() 
gen u  = rnormal() 
gen y  = 5.5*x + 12*u 
qui reg y x 
predict yhat1 
predict uhat1, residual 
twoway (lfit uhat1 x , lcolor(black) lwidth(large)) (scatter uhat1 x , mcolor(black) msymbol(point))
qui graph export "files/graph5.svg", replace
```  

![](files/graph5.svg) 

:::


## Properties of OLS {.smaller background="#bfc4d9"}

Let's say you estimate a model and find the $\hat{\mu}$.

If you calculate the correlation between the X and $\hat{\mu}$, you will find zero.

**This is by construction!** It is not an evidence that CMI is nos violated.

In fact, the OLS "assumes" and "forces" zero correlation.

**It is intuitive: if you are "forcing" zero correlation when the correlation is not in fact zero, your coefficients will be biased.**

The previous graphs actually show zero correlation. But that is expected and does not suggest the model is not violating CMI.

**At the end of the day, CMI is untestable and unverifiable**.









# Goodness-of-fit {.smaller background="#dff2c7"}

## Goodness-of-fit {.smaller background="#dff2c7"}

**Understanding what SSR, SSE and SST mean** 

- SSE = Sum of Squares Explained = $\sum_i^n(\hat{y_i}-\bar{y})^2$
- SSR = Sum of Squares Residuals = $\sum_i^n\hat{\mu}^2$
- SST = Sum of Squares Total = SSE + SSR = $\sum_i^n(y_i-\hat{y_i})^2$ 


R-squared is simply the ratio of portion explained over the total that could be explained.


$$R^2 = \frac{SSE}{SST} = 1-\frac{SSR}{SST}$$



## Goodness-of-fit {.smaller background="#dff2c7"}

![](figs/R2.jpg)





## Goodness-of-fit {.smaller background="#dff2c7"}

You can think this way:

1) If X does not explain Y, then the best predictor of Y is $\bar{y}$. In that case, your model does not explain anything of Y, thus $R^2$ is zero, and $\hat{y_i}=\bar{y}$

. . .

2) If X partially explains Y, then $\hat{y_i} \neq \bar{y}$, meaning that $\hat{y_i}$ has some inclination (like the figure next slide). This means that $SSE>0$ and your $R^2>0$ but $R^2<1$

. . .

3) Whatever is not explained by $\hat{y_i}$ is left to $\sum_i^2\hat{\mu}^2$, meaning that SSR will be non-zero.

. . .

4) The ratio of the portion that you can explain by  $\hat{y_i}$ over the total that is to be explained  $y_i-\hat{y_i}$ if the $R^2$.






## Goodness-of-fit {.smaller background="#dff2c7"}


::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(foreign) # importing dataset from a stata dta file
data <- read.dta("files/CEOSAL1.dta")
attach(data)
# Statistics of salary 
mean(salary)
# OLS model
model <- lm(salary ~ roe)
salaryhat <- fitted(model)                      # Predict values for dependent variable
uhat <- resid(model)                            # Predict regression residuals
salarymean <- rep(mean(salary),length(salary))  # Generating the mean of salary 
summary(model)
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import statsmodels.api as sm
data = pd.read_stata("files/CEOSAL1.dta")
print(data['salary'].mean())
# OLS model
X = data['roe']
X = sm.add_constant(X)
y = data['salary']

model = sm.OLS(y, X).fit()  # Fit the linear regression model
salaryhat = model.fittedvalues  # Predicted values for the dependent variable
uhat = model.resid  # Predict regression residuals
salarymean = pd.Series([y.mean()] * len(y))  # Generating the mean of salary
print(model.summary())
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace
sum salary 
reg salary roe 
predict salaryhat , xb				
predict uhat, resid					
egen salarymean = mean(salary)		
```  

:::












## Goodness-of-fit {.smaller background="#dff2c7"}

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(foreign) # importing dataset from a stata dta file
mydata <- read.dta("files/CEOSAL1.dta")
attach(mydata)
model <- lm(salary ~ roe)
salaryhat <- fitted(model)                      # Predict values for dependent variable
uhat <- resid(model)                            # Predict regression residuals
salarymean <- rep(mean(salary),length(salary))  # Generating the mean of salary 
# r-squared is simply the ratio of portion explained over total that could be explained - Understanding what SSR, SSE and SST mean 
plot(salary ~ roe)
abline(lm(salary ~ roe), col = "blue")
abline(lm(salarymean ~ roe), col = "red")
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
data = pd.read_stata("files/CEOSAL1.dta")
X = data[['roe']]
y = data['salary']
salarymean = np.repeat(y.mean(), len(y))
X_mean = X.mean()
y_mean = y.mean()
slope = np.sum((X - X_mean) * (y - y_mean)) / np.sum((X - X_mean) ** 2)
intercept = y_mean - slope * X_mean
salaryhat = slope * X + intercept
# Plotting the data and regression lines
plt.scatter(X, y,  alpha=0.7)
plt.plot(X, salaryhat,  color='blue', linewidth=2)
plt.plot(X, salarymean, color='red',  linewidth=2)
plt.xlabel('roe')
plt.ylabel('salary')
plt.show()
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: false
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace
sum salary , d
reg salary roe 
predict salaryhat , xb				
predict uhat, resid					
egen salarymean = mean(salary)		

twoway (scatter salary roe) (lfit salary roe) (lfit salarymean roe) 
qui graph export "files/graph4_6.svg", replace
```  

![](files/graph4_6.svg) 

:::










## Goodness-of-fit {.smaller background="#dff2c7"}

Manually calculating $R^2$

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(foreign) # importing dataset from a stata dta file
mydata <- read.dta("files/CEOSAL1.dta")
attach(mydata)
model <- lm(salary ~ roe)
salaryhat <- fitted(model)                      # Predict values for dependent variable
uhat <- resid(model)                            # Predict regression residuals
salarymean <- rep(mean(salary),length(salary))  # Generating the mean of salary 

# r-squared is simply the ratio of portion explained over total that could be explained
ssr  <- sum(uhat^2)
ssrB <- sum((salary    - salaryhat)^2)
sst  <- sum((salary    - salarymean)^2)
sse  <- sum((salaryhat - salarymean)^2)
sse / sst
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
data = pd.read_stata("files/CEOSAL1.dta")
X = data['roe']
y = data['salary']
X = sm.add_constant(X)  # Add a constant term (intercept)
model = sm.OLS(y, X).fit()
salaryhat = model.fittedvalues
uhat = model.resid
salarymean = np.repeat(y.mean(), len(y))
# Calculate R-squared
ssr = np.sum(uhat**2)
ssrB = np.sum((y - salaryhat)**2)
sst = np.sum((y - salarymean)**2)
sse = np.sum((salaryhat - salarymean)**2)
rsquared = sse / sst
print(rsquared)
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace
qui reg salary roe 
predict salaryhat , xb				
predict uhat, resid					
egen salarymean = mean(salary)		
egen sst  = total((salary    - salarymean)^2)  
egen ssr  = total((salary    - salaryhat)^2)
egen ssrB = total(uhat^2)					
egen sse  = total((salaryhat - salarymean)^2)	
di sse / sst
```  

:::







# Variance of coefficients {.smaller background="#c4f5d7"}

## Variance of coefficients {.smaller background="#c4f5d7"}

When we estimate coefficients we have some "error of estimation".

- Basically, you are searching the "true" coefficient using a sample, which should be representative of the population but it is not the population itself.

- This means that the coefficient estimated is estimated with error.

- We would like (e.g., we will need) to impose some "structure" to that error.






## Variance of coefficients {.smaller background="#c4f5d7"}

**Standard error and T-stat**

To assess if the variables are significantly related, you need to assess the significance of $\beta$ coefficients.

Using the example from Wooldridge, we know that the Beta of ROE is `18.591`, while the standard error of ROE is `11.123`.

. . .

- The standard error is a measure of the accuracy of your estimate. If you find a large standard error, your estimate does not have good accuracy. 

- Ideally, you would find small standard errors, meaning that your coefficient is accurately estimated. 

- However, you do not have good control over the magnitude of the standard errors. 






## Variance of coefficients {.smaller background="#c4f5d7"}

**Standard error and T-stat**

If you have a large standard error, probably you coefficient will not be significantly different from zero. You can test whether your coefficient is significantly different from zero computing the t-statistics as follows:

$$t_{\beta} = \frac{\hat{\beta}}{se(\hat{\beta})}$$

If $t_{\beta}$ is large enough, you can say that $\beta$ is significantly different from zero. Usually, $t_{\beta}$ larger than 2 is enough to be significant. 





## Variance of coefficients {.smaller background="#c4f5d7"}

In the previous example, you can find the t-stat manually as follows ($t_{\beta} =\frac{\hat{\beta}}{se(\hat{\beta})}$):

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(foreign) # importing dataset from a stata dta file
data <- read.dta("files/CEOSAL1.dta")
attach(data)
# OLS model
model <- lm(salary ~ roe)
summary(model)$coefficients[2,1] / summary(model)$coefficients[2,2] 
summary(model)$coefficients[2,3]
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import statsmodels.api as sm
data = pd.read_stata("files/CEOSAL1.dta")
# OLS model
X = data['roe']
X = sm.add_constant(X)
y = data['salary']
model = sm.OLS(y, X).fit()  
# Extract and calculate specific coefficients
coef_beta = model.params['roe']
coef_std_error = model.bse['roe']
# Calculate t-value
t_value = coef_beta / coef_std_error
# Print the coefficient and t-value
print("Coefficient (beta):", coef_beta)
print("Standard Error:", coef_std_error)
print("t-value:", t_value)
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace
qui reg salary roe 
local beta = _b[roe]
local std_error = _se[roe]
local t_value = `beta' / `std_error'
display "Coefficient (beta): " `beta'
display "Standard Error: " `std_error'
display "t-value: " `t_value'
```  

:::







## Variance of coefficients {.smaller background="#c4f5d7"}

Naturally, the previous analysis requires an estimate of $\beta$ and an estimate of the $\beta$'s standard error.


The standard error can be defined as:

$$se(\hat{\beta_1})=\frac{\hat{\sigma}}{\sqrt{SST_x}}$$

- Where $\hat{\sigma}$ is the standard deviation of the error term in the regression, which can be calculated as:

$$\hat{\sigma} = \sqrt{\frac{SSR}{n-2}}$$

    - The $n-2$ here is an adjustment for the degrees of freedom in the regression.

- SST is defined as before $\sum_i^n(y_i-\hat{y_i})^2$ 










## Variance of coefficients {.smaller background="#c4f5d7"}

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(foreign) # importing dataset from a stata dta file
data <- read.dta("files/CEOSAL1.dta")
attach(data)
# OLS model
model <- lm(salary ~ roe)
# Extract the standard error of the coefficient for 'roe'
summary(model)$coefficients["roe", "Std. Error"]

#calculating manually
# Extract the residuals
residuals <- resid(model)
# Number of observations (n)
n <- length(residuals)
# Calculate the mean of the independent variable (roe)
roe_mean <- mean(roe)
# Calculate the sum of squared deviations of roe from its mean (SXX)
SST <- sum((roe - roe_mean)^2)
# Calculate the sum of squared errors (SSE)
SSR <- sum(residuals^2)
# Calculate the standard error of beta
Sd_beta <- sqrt(SSR / ((n - 2)))
# Calculate S.E
Se_beta <- Sd_beta / sqrt(SST)
# Print the standard error of beta
print(Se_beta)
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import numpy as np
import statsmodels.api as sm
data = pd.read_stata("files/CEOSAL1.dta")
X = data['roe']
y = data['salary']
X = sm.add_constant(X)  
model = sm.OLS(y, X).fit()
# Extract the standard error of the coefficient for 'roe'
beta_se_summary = model.bse['roe']
print("Standard Error (from summary):", beta_se_summary)
# Calculate it manually
# Extract the residuals
residuals = model.resid
# Number of observations (n)
n = len(residuals)
# Calculate the mean of the independent variable (roe)
roe_mean = X['roe'].mean()
# Calculate the sum of squared deviations of roe from its mean (SST)
SST = np.sum((X['roe'] - roe_mean) ** 2)
# Calculate the sum of squared errors (SSE)
SSE = np.sum(residuals ** 2)
# Calculate the standard error of beta (Sd_beta)
Sd_beta = np.sqrt(SSE / (n - 2))
# Calculate SE_beta
SE_beta = Sd_beta / np.sqrt(SST)
print("Standard Error (manually calculated):", SE_beta)
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace
qui reg salary roe 
gen beta_se_summary = _se[roe]
gen n = _N
predict residuals, residuals
sum roe, meanonly
gen roe_diff = roe - r(mean)
egen roe_diff_sq = total(roe_diff^2)
gen residuals_sq = residuals^2
egen residuals_sq_sum = total(residuals_sq)
gen Sd_beta = sqrt(residuals_sq_sum / (n - 2))
gen SE_beta = Sd_beta / sqrt(roe_diff_sq)
display "Standard Error (from summary): " sum(beta_se_summary)
display "Standard Error (manually calculated): " sum(SE_beta)
```  

:::











## Variance of coefficients {.smaller background="#c4f5d7"}

**Another comment:**

$$se(\hat{\beta_1})=\frac{\hat{\sigma}}{\sqrt{SST_x}}$$

1) The larger $\hat{\sigma}$ is, the larger the variance of $\beta$. That is, the more "noise" in the association between x and Y, the harder it is to learn something about $\beta$.

2) However, more variation in x, the larger the SST, so the smaller is the variance of $\beta$.









# Robust standard errors {.smaller background="#e0cafc"}


##  Robust standard errors {.smaller background="#e0cafc"}

Looking at both equations below:

$$t_{\beta} = \frac{\hat{\beta}}{se(\hat{\beta})}$$


$$se(\hat{\beta_1})=\frac{\hat{\sigma}}{\sqrt{SST_x}}$$


**What happens if $\hat{\sigma}$ is not constant (for the values of x)?**

**In other words, how realistic is to assume that the variance in the errors is the same for all slices of x?**

**Can you think of an example where that may happen?**




##  Robust standard errors {.smaller background="#e0cafc"}

**Earnings = f(education)**

PhD have a higher variance of earnings than non-educated people.

. . .

**Leveragge=f(Size)**

It is quite possible that small firms will have less options of leverage than large companies. 

This means that a sub-sample of large companies will have higher variance in the leverage decisions (and thus the error terms) than the sub-sample of small firms






##  Robust standard errors {.smaller background="#e0cafc"}

One of the key assumptions in OLS estimators is homoscedasticity 

That is, the assumption is that the variance of the errors is homoscedastic (constant variance in all slices of X). 

It means that throughout all observations, the error term shows the **same variance**. 

If errors are not homoscedastic, we have the heteroscedasticity problem.


. . . 

Heteroskedasticity **does not cause bias or inconsistency in the OLS estimators** of the $\beta$ like the OVB would. 

It also does not affect the $R^2$. 

**What Heteroscedasticity does is to bias the standard errors of the estimates.**







##  Robust standard errors {.smaller background="#e0cafc"}

![](files/homoscedasticity.png)




##  Robust standard errors {.smaller background="#e0cafc"}



![](files/heteroscedasticity.png)








##  Robust standard errors {.smaller background="#e0cafc"}

**Homoskedascticity** = Constant $\hat{\sigma}$ to all slices of X.

**Heteroskedascticity** = Non-constant $\hat{\sigma}$ to all slices of X.

**Without homoskedascticity, OLS no longer has the minimum mean squared errors**, which means that the *estimated standard errors are biased*, which in turn creates bias in the t-stat and the inference you'll make with your model.
 

. . . 

Fortunately, we have an easy solution for that.


$$Var(\hat{\beta_1}) = \frac{\sum_i^n(x_i-\bar{x})^2\hat{\mu}^2}{SST^2_x}$$

This formula simply "includes" the heteroskedascticity in the calculation of $Var(\hat{\beta_1})$, meaning this correct the estimated standard deviation to heteroskedascticity.

We call this correction as **Robust Standard Errors** (White Robust).

. . .

In other words, you should always use Robust Standard Errors. It is easy to use it with R.










##  Robust standard errors {.smaller background="#e0cafc"}

**Using Robust Standard-errors.**

::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(sandwich)
library(foreign) 
library(lmtest)

data <- read.dta("files/CEOSAL1.DTA")
model <- lm(salary ~ roe, data = data)
robust_model <- coeftest(model, vcov = vcovHC(model, type = "HC3"))
SE_beta_robust <- robust_model["roe", "Std. Error"]
cat("Robust Standard Error :", SE_beta_robust, "\n")
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
data = pd.read_stata("files/CEOSAL1.DTA")
model = smf.ols("salary ~ roe", data=data)
results = model.fit(cov_type='HC3')  
SE_beta_robust = results.bse['roe']
print("Robust Standard Error :", SE_beta_robust)
```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace

qui reg salary roe 
gen beta_se_non = _se[roe]

qui reg salary roe , robust
gen beta_se_summary = _se[roe]

di "Standard Error (non-robust): " sum(beta_se_non)
di "Standard Error (robust): " sum(beta_se_summary)
```  

:::




##  Robust standard errors {.smaller background="#e0cafc"}


Notice that the standard errors have changed quite significantly  in this example. 

Usually, the robust standard errors are larger than the traditional ones in empirical works.

**But, in this example, they are smaller.**

. . . 

Perhaps more importantly:

**Once the S.e. change, you should expect that the t-stat of the estimates also change.**


. . . 


**Final comment**: robust standard errors are robust in the case of homoskedasticity.

::: {.callout-warning}
Thus, you should always use robust S.E.
:::









# Clustered standard errors {.smaller background="#edc5d1"}

## Clustered standard errors {.smaller background="#edc5d1"}

Almost always, someone will ask you whether you clustered your standard errors.

**The intuition is the following:**

- When you do not cluster, you are assuming that all observations are independently and identically distributed (i.i.d.), which may or may not be true.

- Imagine you are studying the effect of class size on students achievement.

- How much of a effect would **have the teacher of a class**? 

. . . 

- In this design, the teacher influences the achievement of all the students in the same class, and one teacher cannot be at two classes at the same time.

- Thus, it would be wise to cluster the errors at the class-level. This assumes that the residual of each individual is clustered with the other individuals in the same class.


. . .

In principle, clustering solves any form of dependence of the residuals in your data.








## Clustered standard errors {.smaller background="#edc5d1"}

In corporate finance/accounting research panel data research, the tradition is to cluster at the **firm-level**.

- The reason is that the observations of the same firm are not independent trough time, thus are correlated. 

But, there is a lot of debate about this decision. 

. . .

The tip is to cluster where the **randomness exist**. That is quite subjective. In the class size example, the **randomness** comes out of the teacher, since each teacher has their own ways of teaching (materials, resources, etc.).

. . .
 
But, it is a good practice to stress this decision a bit in your own research by **also showing results with clustered s.e. at the industry-level**.

. . .

**Final tip**: usually the minimum number of cluster is about 30. Less than that might be insufficient (but, again, the guidance in this topic is very subjective).  



 


## Clustered standard errors {.smaller background="#edc5d1"}

The clustered standard errors are different because I am fabricating the clusters here for the sake of the coding.

In your real research, you would have the cluster at hands. 


::: panel-tabset
### R

```{r}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output-location: default
#| code-fold: true
#| code-summary: "R"
#| code-line-numbers: true
#| eval: true
library(sandwich)
library(foreign) 
library(lmtest)
library(plm)

data <- read.dta("files/CEOSAL1.DTA")
model <- lm(salary ~ roe, data = data)
robust_model <- coeftest(model, vcov = vcovHC(model, type = "HC3"))
#clustered
data$cluster <- rep(1:35, length.out = nrow(data))
model <- plm(salary ~ roe, data = data, index = c("cluster"))

clustered_se <- vcovHC(model, type = "HC3", cluster = "group")
SE_beta_clustered <- sqrt(clustered_se["roe", "roe"])

cat("Standard Error (robust):", SE_beta_robust, "\n")
cat("Standard Error (clustered)::", SE_beta_clustered, "\n")
```

### Python

```{python}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Python"
import pandas as pd
import statsmodels.api as sm

# Read the dataset
data = pd.read_stata("files/CEOSAL1.DTA")

# Create a new variable 'cluster' with cluster numbers ranging from 1 to 35
data['cluster'] = list(range(1, 36)) * (len(data) // 35)

# Fit the linear regression model
model = sm.OLS(data['salary'], sm.add_constant(data['roe'])).fit()

# Compute robust standard errors
robust_model = model.get_robustcov_results(cov_type='HC3')
SE_beta_robust = robust_model.cov_params().loc['roe', 'roe'] ** 0.5

# Fit the linear regression model with clustered standard errors
model_clustered = sm.OLS(data['salary'], sm.add_constant(data['roe'])).fit(cov_type='cluster', cov_kwds={'groups': data['cluster']})

# Extract the clustered standard errors for 'roe'
clustered_se = model_clustered.HC3_se.loc['roe']

print("Robust Standard Error (HC3):", SE_beta_robust)
print("Clustered Standard Error (HC3):", clustered_se)

```

### Stata

```{stata}
#| warning: false
#| message: false
#| fig-align: center
#| echo: true
#| output: true
#| output-location: default
#| code-fold: true
#| code-line-numbers: true
#| eval: true
#| code-summary: "Stata"
use "files/CEOSAL1.DTA" , replace

qui reg salary roe 
gen beta_se_non = _se[roe]

qui reg salary roe , robust
gen beta_se_summary = _se[roe]

egen cluster = seq(), block(6)
qui regress salary roe , vce(cluster cluster)
gen SE_beta_clustered = _se[roe]

di "Standard Error (non-robust): " sum(beta_se_non)
di "Standard Error (robust): " sum(beta_se_summary)
di "Standard Error (clustered): " sum(SE_beta_clustered)
```  

:::










## **THANK YOU!** {background="#b1cafa"}

::: columns
::: {.column width="60%"}
**QUESTIONS?**

![](figs/qa2.png){width="150%" heigth="150%"}
:::

::: {.column width="40%"}
**Henrique C. Martins**

-   [FGV/EAESP](https://eaesp.fgv.br/en/people/henrique-castro-martins)
-   [Personal Website](https://henriquemartins.net/)
-   [LinkedIn](https://www.linkedin.com/in/henriquecastror/)
-   [Lattes](http://lattes.cnpq.br/6076997472159785)
-   [Scholar](https://scholar.google.com.br/citations?user=7gIfkRMAAAAJ&hl=pt-BR&oi=ao)\
:::
:::

::: footer
:::
