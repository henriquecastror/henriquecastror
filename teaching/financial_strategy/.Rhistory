}
if (length(items) == 0) {
return(data.frame(question_id=character(), qtype=character(), correct_value=character(), tolerance=double(), stringsAsFactors = FALSE))
}
df <- do.call(rbind.data.frame, lapply(items, as.data.frame))
df <- df[!duplicated(df$question_id), ]
rownames(df) <- NULL
df$qtype <- tolower(df$qtype)
df$correct_value <- as.character(df$correct_value)
df$tolerance[!(df$qtype %in% c("num"))] <- NA_real_
df
}
# Hash simples do QMD (opcional; útil p/ versões)
version_hash_of_qmd <- function(qmd_path) {
txt <- readLines(qmd_path, warn = FALSE)
norm <- gsub("\\s+", " ", trimws(txt))
digest(paste(norm, collapse = "\n"), algo = "sha256")
}
# POST para /exercises/answer-key
post_answer_key <- function(payload, endpoint = ENDPOINT_ANSWER_KEY, admin_token = admin_token) {
req <- httr2::request(endpoint) |>
httr2::req_method("POST") |>
httr2::req_headers("content-type" = "application/json", "x-admin-token" = admin_token) |>
httr2::req_body_json(payload)
resp <- httr2::req_perform(req)
list(status = httr2::resp_status(resp), body = tryCatch(httr2::resp_body_string(resp), error = function(e) ""))
}
points_for <- function(qtype) {
if (!USE_POINTS_LOCAL) return(NULL)
POINTS_BY_TYPE[[tolower(qtype)]] %||% NULL
}
# -------- Pipeline principal (lote) --------
run_ingest_batch <- function(files = FILES, file_meta = FILE_META) {
# checagem rápida de chaves
if (!setequal(files, names(file_meta))) stop("FILES e names(FILE_META) precisam casar 1:1.")
summary <- list()
for (qmd in files) {
meta   <- file_meta[[qmd]]
module <- meta$module
slideid<- meta$slideid
seeds  <- meta$seeds; if (length(seeds) == 0) seeds <- 121213
message("\n=== Arquivo: ", qmd, " | seeds: ", paste(seeds, collapse = ","), " ===")
# detecta se é questão numérica pelo path/id
is_numeric_q <- grepl("/num/|_num_", qmd, ignore.case = TRUE)
seed_results <- list()
for (sd in seeds) {
# usa seed só se for num; caso contrário, usa o próprio arquivo
if (is_numeric_q) {
tmp_qmd <- make_temp_qmd_with_seed(qmd, sd)
} else {
tmp_qmd <- qmd
}
out_dir  <- file.path(tempdir(), paste0("render_", path_ext_remove(path_file(qmd)), "_", sd))
out_dir  <- normalizePath(out_dir, winslash = "/", mustWork = FALSE)
dir_create(out_dir, recurse = TRUE)
html_out <- render_qmd_to_html(tmp_qmd, out_dir)
df <- extract_items_from_html(html_out)
if (nrow(df) == 0) {
message("  [seed ", sd, "] Nenhum input com data-correct-answer encontrado. Pulando.")
if (is.numeric_q <- isTRUE(is_numeric_q)) try(file_delete(tmp_qmd), silent = TRUE)
next
}
items <- lapply(seq_len(nrow(df)), function(i) {
list(
question_id   = df$question_id[i],
qtype         = df$qtype[i],
correct_value = df$correct_value[i],
tolerance     = if (is.na(df$tolerance[i])) NULL else unname(df$tolerance[i]),
points        = points_for(df$qtype[i]),
module        = module,
slideid       = slideid
)
})
payload <- list(slide_id = slideid, items = items)
res <- post_answer_key(payload)
message("  [seed ", sd, "] HTTP ", res$status, " | ", substr(res$body, 1, 240))
seed_results[[as.character(sd)]] <- list(status = res$status, body = res$body)
# limpeza
if (isTRUE(is_numeric_q)) try(file_delete(tmp_qmd), silent = TRUE)
try(dir_delete(out_dir), silent = TRUE)
}
summary[[qmd]] <- seed_results
}
invisible(summary)
}
# -------- Execução --------
# (opcional) verificação de chaves FILES vs FILE_META
if (!setequal(FILES, names(FILE_META))) {
cat("ATENÇÃO: FILES e names(FILE_META) não casam 1:1.\n")
print(FILES); print(names(FILE_META))
stop("Ajuste FILE_META para ter as mesmas chaves de FILES.")
}
resumo <- run_ingest_batch(FILES, FILE_META)
# -------- Configurações principais --------
ENDPOINT_ANSWER_KEY <- "https://course-chat.hcmrtns.workers.dev/exercises/answer-key"
ADMIN_TOKEN_ENV     <- "ADMIN_TOKEN"   # defina no seu ambiente
USE_POINTS_LOCAL    <- TRUE            # se FALSE, envia points = NULL (centralize em D1)
POINTS_BY_TYPE      <- list(tf = 1L, mcq = 1L, num = 2L, long = 5L)
# Liste aqui os arquivos do lote (caminhos relativos ao repo)
FILES <- c(
"module1/tf/module1_tf_q1.qmd",
"module1/mcq/module1_mcq_q1.qmd",
"module1/num/module1_num_q1.qmd",
"module1/long/module1_long_q1.qmd"
)
# Metadados por arquivo — AS CHAVES DEVEM SER IGUAIS AOS PATHS EM FILES
FILE_META <- list(
"module1/tf/module1_tf_q1.qmd"     = list(module = "mod1", slideid = "module1_tf_demo",   seeds = c(121213)),
"module1/mcq/module1_mcq_q1.qmd"   = list(module = "mod1", slideid = "module1_mcq_demo",  seeds = c(121213)),
"module1/num/module1_num_q1.qmd"   = list(module = "mod1", slideid = "module1_num_demo",  seeds = 121213 + 0:9),
"module1/long/module1_long_q1.qmd" = list(module = "mod1", slideid = "module1_long_demo", seeds = c(121213))
)
# -------- Pacotes --------
ensure_pkg <- function(pkgs) for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
ensure_pkg(c("fs", "xml2", "stringr", "jsonlite", "httr2", "digest"))
library(fs)
library(xml2)
library(stringr)
library(jsonlite)
library(httr2)
library(digest)
`%||%` <- function(a,b) if (is.null(a) || is.na(a)) b else a
# -------- Utilitários --------
admin_token <- Sys.getenv(ADMIN_TOKEN_ENV, unset = NA)
if (is.na(admin_token) || admin_token == "") stop(sprintf("Variável de ambiente %s não definida.", ADMIN_TOKEN_ENV))
norm_path <- function(p, mustWork = TRUE) normalizePath(p, winslash = "/", mustWork = mustWork)
# Renderiza para HTML usando um output-dir ao lado do QMD
render_qmd_to_html <- function(qmd_path, out_dir) {
if (!file_exists(qmd_path)) stop("Arquivo não encontrado: ", qmd_path)
fs::dir_create(out_dir, recurse = TRUE)
qmd_norm <- norm_path(qmd_path, mustWork = TRUE)
out_norm <- norm_path(out_dir, mustWork = FALSE)
cmd  <- "quarto"
args <- c("render", qmd_norm, "--to", "html", "--output-dir", out_norm)
status <- tryCatch(system2(cmd, args, stdout = TRUE, stderr = TRUE), error = function(e) as.character(e))
html_name <- fs::path_ext_set(fs::path_file(qmd_path), "html")
html_path <- fs::path(out_norm, html_name)
if (!file_exists(html_path)) {
stop("Falha ao renderizar HTML (verifique quarto e o arquivo): ", qmd_path,
"\nSaída:\n", paste(status, collapse = "\n"))
}
return(html_path)
}
# Cria cópia temporária do QMD (no MESMO diretório) substituindo set.seed(<seed>)
make_local_qmd_with_seed <- function(qmd_path, seed) {
base_dir <- fs::path_dir(qmd_path)
base_nm  <- fs::path_ext_remove(fs::path_file(qmd_path))
tmp_path <- fs::path(base_dir, paste0(base_nm, "_seed", seed, "_.qmd"))
txt <- readLines(qmd_path, warn = FALSE)
pattern <- "\\bset\\.seed\\s*\\([^\\)]*\\)"
replacement <- sprintf("set.seed(%s)", as.character(seed))
txt2 <- if (any(grepl(pattern, txt))) {
gsub(pattern, replacement, txt)
} else {
open_idx <- which(grepl("^```\\{r", txt, perl = TRUE))[1]
if (is.na(open_idx)) c("```{r}", replacement, "```", txt) else append(txt, values = c(replacement), after = open_idx)
}
writeLines(txt2, tmp_path, useBytes = TRUE)
return(tmp_path)
}
# Heurística do tipo
infer_qtype <- function(node) {
type <- tolower(xml_attr(node, "type") %||% "")
id   <- tolower(xml_attr(node, "id") %||% "")
if (type == "number") return("num")
if (grepl("_num_", id)) return("num")
if (grepl("_tf_",  id)) return("tf")
if (type %in% c("radio","checkbox")) return("mcq")
if (grepl("_mcq_", id)) return("mcq")
corr <- tolower(xml_attr(node, "data-correct-answer") %||% "")
if (corr %in% c("t","f","true","false")) return("tf")
return("long")
}
# Extrai gabaritos do HTML
extract_items_from_html <- function(html_path) {
doc <- read_html(html_path)
items <- list()
# MCQ via <form data-correct-answer="A">
forms_with_correct <- xml_find_all(doc, ".//form[@data-correct-answer]")
if (length(forms_with_correct) > 0) {
for (frm in forms_with_correct) {
corr_letter <- toupper(trimws(xml_attr(frm, "data-correct-answer") %||% ""))
radios <- xml_find_all(frm, ".//input[@type='radio']")
if (length(radios) > 0 && nzchar(corr_letter)) {
ids <- toupper(xml_attr(radios, "id")); ids <- ids[!is.na(ids)]
qid <- if (length(ids) > 0) sub("_[A-E]$", "", ids[1]) else (toupper(xml_attr(frm, "id") %||% paste0("MCQ_", digest::digest(corr_letter))))
items[[length(items)+1]] <- list(question_id=qid, qtype="mcq", correct_value=corr_letter, tolerance=NA_real_)
}
}
}
# Qualquer nó com data-correct-answer
nodes <- xml_find_all(doc, ".//*[@data-correct-answer]")
for (nd in nodes) {
if (xml_name(nd) == "form") next
id  <- xml_attr(nd, "id") %||% ""
if (!nzchar(id)) next
qtype <- infer_qtype(nd)
corr  <- xml_attr(nd, "data-correct-answer") %||% ""
tol   <- xml_attr(nd, "data-tolerance") %||% NA
tol   <- suppressWarnings(as.numeric(tol))
if (qtype == "mcq") {
val <- xml_attr(nd, "value") %||% ""
if (nzchar(val)) {
corr <- toupper(val)
} else {
m <- regexpr("([A-E])$", toupper(id))
if (m > 0) corr <- toupper(substr(id, m, m+attr(m, "match.length")-1))
}
}
items[[length(items)+1]] <- list(
question_id   = id,
qtype         = qtype,
correct_value = as.character(corr),
tolerance     = if (!is.na(tol)) tol else NA_real_
)
}
if (length(items) == 0) {
return(data.frame(question_id=character(), qtype=character(), correct_value=character(), tolerance=double(), stringsAsFactors = FALSE))
}
df <- do.call(rbind.data.frame, lapply(items, as.data.frame))
df <- df[!duplicated(df$question_id), ]
rownames(df) <- NULL
df$qtype <- tolower(df$qtype)
df$correct_value <- as.character(df$correct_value)
df$tolerance[!(df$qtype %in% c("num"))] <- NA_real_
df
}
# (Opcional) hash do QMD
version_hash_of_qmd <- function(qmd_path) {
txt <- readLines(qmd_path, warn = FALSE)
norm <- gsub("\\s+", " ", trimws(txt))
digest(paste(norm, collapse = "\n"), algo = "sha256")
}
# POST para /exercises/answer-key
post_answer_key <- function(payload, endpoint = ENDPOINT_ANSWER_KEY, admin_token = admin_token) {
req <- httr2::request(endpoint) |>
httr2::req_method("POST") |>
httr2::req_headers("content-type" = "application/json", "x-admin-token" = admin_token) |>
httr2::req_body_json(payload)
resp <- httr2::req_perform(req)
list(status = httr2::resp_status(resp), body = tryCatch(httr2::resp_body_string(resp), error = function(e) ""))
}
points_for <- function(qtype) {
if (!USE_POINTS_LOCAL) return(NULL)
POINTS_BY_TYPE[[tolower(qtype)]] %||% NULL
}
# -------- Pipeline principal (lote) --------
run_ingest_batch <- function(files = FILES, file_meta = FILE_META) {
if (!setequal(files, names(file_meta))) stop("FILES e names(FILE_META) precisam casar 1:1.")
summary <- list()
for (qmd in files) {
meta    <- file_meta[[qmd]]
module  <- meta$module
slideid <- meta$slideid
seeds   <- meta$seeds; if (length(seeds) == 0) seeds <- 121213
message("\n=== Arquivo: ", qmd, " | seeds: ", paste(seeds, collapse = ","), " ===")
# detecta se é questão numérica pelo path/id
is_numeric_q <- grepl("/num/|_num_", qmd, ignore.case = TRUE)
base_dir <- fs::path_dir(qmd)
seed_results <- list()
for (sd in seeds) {
# Para num: cria cópia local com seed; demais: usa o arquivo original
if (is_numeric_q) {
tmp_qmd <- make_local_qmd_with_seed(qmd, sd)
} else {
tmp_qmd <- qmd
}
# output-dir ao lado do QMD (mesmo drive)
out_dir  <- fs::path(base_dir, paste0(".render_", sd))
out_dir  <- norm_path(out_dir, mustWork = FALSE)
fs::dir_create(out_dir, recurse = TRUE)
html_out <- render_qmd_to_html(tmp_qmd, out_dir)
df <- extract_items_from_html(html_out)
if (nrow(df) == 0) {
message("  [seed ", sd, "] Nenhum input com data-correct-answer encontrado. Pulando.")
if (isTRUE(is_numeric_q)) try(fs::file_delete(tmp_qmd), silent = TRUE)
try(fs::dir_delete(out_dir), silent = TRUE)
next
}
items <- lapply(seq_len(nrow(df)), function(i) {
list(
question_id   = df$question_id[i],
qtype         = df$qtype[i],
correct_value = df$correct_value[i],
tolerance     = if (is.na(df$tolerance[i])) NULL else unname(df$tolerance[i]),
points        = points_for(df$qtype[i]),
module        = module,
slideid       = slideid
)
})
payload <- list(slide_id = slideid, items = items)
res <- post_answer_key(payload)
message("  [seed ", sd, "] HTTP ", res$status, " | ", substr(res$body, 1, 240))
seed_results[[as.character(sd)]] <- list(status = res$status, body = res$body)
# limpeza
if (isTRUE(is_numeric_q)) try(fs::file_delete(tmp_qmd), silent = TRUE)
try(fs::dir_delete(out_dir), silent = TRUE)
}
summary[[qmd]] <- seed_results
}
invisible(summary)
}
# -------- Execução --------
if (!setequal(FILES, names(FILE_META))) {
cat("ATENÇÃO: FILES e names(FILE_META) não casam 1:1.\n")
print(FILES); print(names(FILE_META))
stop("Ajuste FILE_META para ter as mesmas chaves de FILES.")
}
resumo <- run_ingest_batch(FILES, FILE_META)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
Sys.getenv(18317799tgA!)
Sys.getenv('18317799tgA!')
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
Sys.getenv(18317799tgA!)
rlang::last_trace()
Sys.setenv(ADMIN_TOKEN = "18317799tgA!")
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
Sys.setenv(ADMIN_TOKEN = "18317799tgA!")
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
rlang::last_trace()
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
# Renderiza para HTML, forçando o arquivo de saída exato (sem subpastas)
# Renderiza para HTML usando --output-dir e localiza o .html recursivamente
render_qmd_to_html <- function(qmd_path, out_dir) {
if (!fs::file_exists(qmd_path)) stop("Arquivo não encontrado: ", qmd_path)
fs::dir_create(out_dir, recurse = TRUE)
qmd_norm <- normalizePath(qmd_path, winslash = "/", mustWork = TRUE)
out_norm <- normalizePath(out_dir, winslash = "/", mustWork = FALSE)
cmd  <- "quarto"
args <- c("render", qmd_norm, "--to", "html", "--output-dir", out_norm)
status <- tryCatch(system2(cmd, args, stdout = TRUE, stderr = TRUE),
error = function(e) as.character(e))
# nome do arquivo que esperamos (só o basename)
html_name <- fs::path_ext_set(fs::path_file(qmd_path), "html")
# 1) tenta no topo do out_dir
candidate <- fs::path(out_norm, html_name)
if (fs::file_exists(candidate)) return(candidate)
# 2) procura recursivamente (o Quarto pode criar subpastas)
htmls <- fs::dir_ls(out_norm, recurse = TRUE, type = "file", glob = "*.html")
htmls <- htmls[fs::path_file(htmls) == html_name]
if (length(htmls) == 1) return(htmls[[1]])
stop("Falha ao renderizar HTML (verifique quarto e o arquivo): ", qmd_path,
"\nSaída:\n", paste(status, collapse = "\n"))
}
# Cria cópia temporária do QMD (no MESMO diretório) substituindo set.seed(<seed>)
make_local_qmd_with_seed <- function(qmd_path, seed) {
base_dir <- fs::path_dir(qmd_path)
base_nm  <- fs::path_ext_remove(fs::path_file(qmd_path))
tmp_path <- fs::path(base_dir, paste0(base_nm, "_seed", seed, "_.qmd"))
txt <- readLines(qmd_path, warn = FALSE)
pattern <- "\\bset\\.seed\\s*\\([^\\)]*\\)"
replacement <- sprintf("set.seed(%s)", as.character(seed))
txt2 <- if (any(grepl(pattern, txt))) {
gsub(pattern, replacement, txt)
} else {
open_idx <- which(grepl("^```\\{r", txt, perl = TRUE))[1]
if (is.na(open_idx)) c("```{r}", replacement, "```", txt) else append(txt, values = c(replacement), after = open_idx)
}
writeLines(txt2, tmp_path, useBytes = TRUE)
return(tmp_path)
}
# Heurística do tipo
infer_qtype <- function(node) {
type <- tolower(xml_attr(node, "type") %||% "")
id   <- tolower(xml_attr(node, "id") %||% "")
if (type == "number") return("num")
if (grepl("_num_", id)) return("num")
if (grepl("_tf_",  id)) return("tf")
if (type %in% c("radio","checkbox")) return("mcq")
if (grepl("_mcq_", id)) return("mcq")
corr <- tolower(xml_attr(node, "data-correct-answer") %||% "")
if (corr %in% c("t","f","true","false")) return("tf")
return("long")
}
# Extrai gabaritos do HTML
extract_items_from_html <- function(html_path) {
doc <- read_html(html_path)
items <- list()
# MCQ via <form data-correct-answer="A">
forms_with_correct <- xml_find_all(doc, ".//form[@data-correct-answer]")
if (length(forms_with_correct) > 0) {
for (frm in forms_with_correct) {
corr_letter <- toupper(trimws(xml_attr(frm, "data-correct-answer") %||% ""))
radios <- xml_find_all(frm, ".//input[@type='radio']")
if (length(radios) > 0 && nzchar(corr_letter)) {
ids <- toupper(xml_attr(radios, "id")); ids <- ids[!is.na(ids)]
qid <- if (length(ids) > 0) sub("_[A-E]$", "", ids[1]) else (toupper(xml_attr(frm, "id") %||% paste0("MCQ_", digest::digest(corr_letter))))
items[[length(items)+1]] <- list(question_id=qid, qtype="mcq", correct_value=corr_letter, tolerance=NA_real_)
}
}
}
# Qualquer nó com data-correct-answer
nodes <- xml_find_all(doc, ".//*[@data-correct-answer]")
for (nd in nodes) {
if (xml_name(nd) == "form") next
id  <- xml_attr(nd, "id") %||% ""
if (!nzchar(id)) next
qtype <- infer_qtype(nd)
corr  <- xml_attr(nd, "data-correct-answer") %||% ""
tol   <- xml_attr(nd, "data-tolerance") %||% NA
tol   <- suppressWarnings(as.numeric(tol))
if (qtype == "mcq") {
val <- xml_attr(nd, "value") %||% ""
if (nzchar(val)) {
corr <- toupper(val)
} else {
m <- regexpr("([A-E])$", toupper(id))
if (m > 0) corr <- toupper(substr(id, m, m+attr(m, "match.length")-1))
}
}
items[[length(items)+1]] <- list(
question_id   = id,
qtype         = qtype,
correct_value = as.character(corr),
tolerance     = if (!is.na(tol)) tol else NA_real_
)
}
if (length(items) == 0) {
return(data.frame(question_id=character(), qtype=character(), correct_value=character(), tolerance=double(), stringsAsFactors = FALSE))
}
df <- do.call(rbind.data.frame, lapply(items, as.data.frame))
df <- df[!duplicated(df$question_id), ]
rownames(df) <- NULL
df$qtype <- tolower(df$qtype)
df$correct_value <- as.character(df$correct_value)
df$tolerance[!(df$qtype %in% c("num"))] <- NA_real_
df
}
# (Opcional) hash do QMD
version_hash_of_qmd <- function(qmd_path) {
txt <- readLines(qmd_path, warn = FALSE)
norm <- gsub("\\s+", " ", trimws(txt))
digest(paste(norm, collapse = "\n"), algo = "sha256")
}
# POST para /exercises/answer-key
post_answer_key <- function(payload, endpoint = ENDPOINT_ANSWER_KEY, token = admin_token) {
hdrs <- list(
"content-type" = "application/json",
"x-admin-token" = token
)
req <- httr2::request(endpoint) |>
httr2::req_method("POST") |>
httr2::req_headers(.headers = hdrs) |>
httr2::req_body_json(payload)
resp <- httr2::req_perform(req)
list(
status = httr2::resp_status(resp),
body   = tryCatch(httr2::resp_body_string(resp), error = function(e) "")
)
}
points_for <- function(qtype) {
if (!USE_POINTS_LOCAL) return(NULL)
POINTS_BY_TYPE[[tolower(qtype)]] %||% NULL
}
Sys.setenv(ADMIN_TOKEN = "18317799tgA!")  # aspas
tok <- trimws(Sys.getenv("ADMIN_TOKEN", ""))
nchar(tok)                                   # deve imprimir o tamanho (>0)
httr2::request("https://course-chat.hcmrtns.workers.dev/admin/ping") |>
httr2::req_headers(.headers = list("x-admin-token" = tok)) |>
httr2::req_perform() |>
httr2::resp_body_string()
tok <- trimws(Sys.getenv("ADMIN_TOKEN", ""))
nchar(tok)  # deve imprimir 12
httr2::request("https://course-chat.hcmrtns.workers.dev/admin/ping") |>
httr2::req_headers("Authorization" = paste("Bearer", tok)) |>
httr2::req_perform() |>
httr2::resp_body_string()
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
# 2) Templates (catálogo)
tpl_items  <- build_templates_payload(FILES, FILE_META)
cat("\n=== Publicando templates ===\n")
cat(post_templates(tpl_items), "\n")
# 3) Instances (html + chaves por parte)
inst_items <- build_instances_payload(FILES, FILE_META)
cat("\n=== Publicando instances ===\n")
cat(substr(post_instances(inst_items), 1, 800), "\n")
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
httr2::request(ENDPOINT_TEMPL) |>
httr2::req_method("POST") |>
httr2::req_headers(Authorization = paste("Bearer", tok)) |>
httr2::req_body_json(list(items = list(list(question_id="ping_tf", module="modX", qtype="tf")))) |>
httr2::req_perform() |>
httr2::resp_status()
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
source("D:/Dropbox/Henrique/git/henriquecastror/teaching/financial_strategy/exercises_all.R", echo=TRUE)
