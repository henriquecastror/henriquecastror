{"title":"Estratégia Financeira","markdown":{"yaml":{"title":"Estratégia Financeira","subtitle":" **Part 3 - ch.11 Optimal Portfolio Choice and the Capital Asset Pricing Model** ","author":[{"name":" **Henrique C. Martins** ","affiliation":"**[![](figs/background6.png){width=300px}](https://eaesp.fgv.br/en)**"}],"date":"last-modified","date-format":"DD-MM-YYYY","title-block-banner":true,"format":{"revealjs":{"slide-number":true,"theme":"simple","chalkboard":true,"preview-links":"auto","logo":"figs/background8.png","css":"logo.css","footer":" **[**Henrique C. Martins**] [[henrique.martins@fgv.br](mailto:henrique.martins@fgv.br)] [[Teaching Resources](https://henriquemartins.net/teaching/)] [[Comments](https://henriquemartins.net/teaching/financial_strategy/part_3.html#/comments)]** ","multiplex":true,"scrollable":true}},"title-slide-attributes":{"data-background-color":"#b1cafa"},"include-after":"<script type=\"text/javascript\">\n  Reveal.on('ready', event => {\n    if (event.indexh === 0) {\n      document.querySelector(\"div.has-logo > img.slide-logo\").style.display = \"none\";\n    }\n  });\n  Reveal.addEventListener('slidechanged', (event) => {\n    if (event.indexh === 0) {\n      Reveal.configure({ slideNumber: null });\n      document.querySelector(\"div.has-logo > img.slide-logo\").style.display = \"none\";\n    }\n    if (event.indexh === 1) {\n      Reveal.configure({ slideNumber: 'c' });\n      document.querySelector(\"div.has-logo > img.slide-logo\").style.display = null;\n    }\n  });\n</script>\n"},"headingText":"library(reticulate)","containsRefs":false,"markdown":"\n\n\n```{r setup}\n#| include: false\n#| warning: false\napi_key <- \"kfqxH5NsN8Nhe_U1NADB\"\n# use_python(\"C:/Users/hcmrt/AppData/Local/Programs/Python/Python310/python.exe\")\nlibrary(reticulate)\n#reticulate::py_install(\"matplotlib\")\n#reticulate::py_install(\"seaborn\")\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(gganimate)\nlibrary(ggthemes)\nlibrary(PerformanceAnalytics)\nlibrary(tidyr)\nlibrary(tidyquant)\nlibrary(roll)\nlibrary(plotly)\nlibrary(yfR)\n```\n\n\n\n\n\n\n# Intro {visibility=\"hidden\"}\n\n## {background-image=\"figs/ch11.png\" background-size=\"1300px\"}\n\n\n\n\n\n\n## Chapter Outline  \n\n11.1 The Expected Return of a Portfolio\n\n11.2 The Volatility of a Two-Stock Portfolio\n\n11.3 The Volatility of a Large Portfolio\n\n11.4 Risk Versus Return: Choosing an Efficient Portfolio\n\n11.5 Risk-Free Saving and Borrowing\n\n11.6 The Efficient Portfolio and Required Returns\n\n11.7 The Capital Asset Pricing Model\n\n11.8 Determining the Risk Premium\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.1 Expected return of a portfolio  {.smaller background=\"#c9f7ba\"}\n\n## 11.1 Expected return of a portfolio  {.smaller background=\"#c9f7ba\"}\n\n**Suppose you have two stocks:**\n\n**Amazon:** $x_1$: 40%, **Return**: 10%, **Risk**: 26.6%\n\n**Southwest:** $x_2$: 60%, **Return**: 15%, **Risk**: 27.9%\n\n. . .\n\nIf your portfolio is 40% Amazon + 60% Southwest, then your return is:\n\n\n$$(0.4 \\times 10\\%) +(0.6 \\times 15\\%) = 13\\%$$\n\n**There is no secret here, the return of a portfolio is the weighted average of returns.**\n\n**The weights are selected by the investors and, obviously, if prices change, the weights change over time.**\n\n\n\n\n\n\n\n\n\n\n\n# 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**To compute the standard deviation of a portfolio, we cannot rely on the weighted average. We have to look to the covariances.** \n\n![](figs/bre13901_0712.jpg){.absolute bottom=\"1\" right=\"1\" width=\"700\"}\n\n- $\\sigma^2_1$ = variance of asset 1. \n- $\\sigma^2_2$ = variance of asset 2\n- $\\sigma_{12}$ = covariance between assets 1 and 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\nCovariance is the product of the assets' Sd and their correlation.\n\n$$\\sigma_{12} = \\sigma_1 \\times \\sigma_2 \\times \\rho_{12}$$\n\nCovariance is the expected product of the deviations of two returns from their means.\n\n$$Cov(R_i,R_j) = E[(R_i-E[R_i]) \\times (R_j-E[R_j]) ]$$\n\n\nWhen using historical data:\n\n$$Cov(R_i,R_j) = \\frac{1}{T-1} (R_i-\\tilde{R_i} ) \\times (R_j-\\tilde{R_j} )$$\n\n. . . \n\nCorrelation:\n\n$$Corr(R_i,R_j) = \\frac{Cov(R_i,R_j)}{Sd(R_i)\\times  Sd(R_j)  }$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\nTherefore, the portfolio variance is:\n\n$$var = (x_1^2 \\times \\sigma_1^2)  + (x_2^2 \\times \\sigma_2^2) + 2(x_1 \\times x_2 \\times \\sigma_1 \\times \\sigma_2 \\times \\rho_{12})$$\n\n. . . \n\nIf $\\rho_{12} = 0.26$ \n\n$$(0.4^2 \\times 26.6^2)  + (0.6^2 \\times 27.9^2) + 2(0.4 \\times 0.6 \\times 26.6 \\times 27.9 \\times 0.26) = 486.1$$\n\nThe standard deviation of the portfolio is $\\sqrt{486.1}= 22\\%$, which is lower than 26.6% and 27.9%.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Covariance and Correlation**\n\nLet's remember the basics about correlation.\n\n![](figs/bm_11_1.png)\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Covariance and Correlation**\n\nThese assets have the same historical return and volatility, **but they 'move' very differently**: \n\n- For example, when North Air performed well, Text Oil tended to do poorly, and when North Air did poorly, Text oil  tended to do well\n\n- **North Air is not positively correlated with  Text Oil.**\n\n- Consider the portfolio which consists of equal investments in West Air and Tex Oil. The average return of the portfolio is equal to the average return of the two stocks...\n\n- ...**However, the volatility of 5.1% is much less than the volatility of the two individual stocks.**\n\n**The amount of risk that is eliminated in a portfolio depends on the degree to which the stocks face common risks and their prices move together.**\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n::: {.panel-tabset}\n\n### R \n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(PerformanceAnalytics)\nlibrary(yfR)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggthemes)\nlibrary(tidyquant)\nlibrary(roll)\nlibrary(plotly)\nlibrary(ggthemes)\nstocks <-c('BBDC3.SA', 'PETR3.SA') \nstart <-'2010-01-01' \nend   <-Sys.Date()  \ndata <- yf_get(tickers = stocks, \n                         first_date = start,\n                         last_date = end)\ndata<-data[complete.cases(data),] \np<-ggplot(data, aes(ref_date , price_close, group=ticker , color=ticker))+\n        geom_line() +\n        labs(x = \"\",\n             y='Closing prices', \n             title=\"Two assets returns\", \n             subtitle = \"Begin 01/01/2010\") +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: false\n#| code-line-numbers: true\t\n#| output-location: slide\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nimport yfinance as yf\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom scipy.stats import norm\nstocks = ['BBDC3.SA', 'PETR3.SA']\nstart = '2010-01-01'\nend = pd.Timestamp.today().strftime('%Y-%m-%d')\ndata = yf.download(stocks, start=start, end=end)['Close']\ndata = data.dropna()\n# plot the data\nplt.close()\nplt.plot(data.index, data['BBDC3.SA'], label='BBDC3.SA')\nplt.plot(data.index, data['PETR3.SA'], label='PETR3.SA')\n# add title and axis labels\nplt.title('Two assets returns')\nplt.xlabel('Date')\nplt.ylabel('Closing prices')\n# add legend\nplt.legend()\n# display the plot\nplt.show()\n```\n\n\n\n::: \n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Same graph using prices in day 1 = $100.**\n\n::: {.panel-tabset}\n\n### R \n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstock1 <- subset(data, ticker == stocks[1])\nstock2 <- subset(data, ticker == stocks[2])\nstock1$price_close2 <- stock1$price_close  / stock1$price_close[1] * 100\nstock2$price_close2 <- stock2$price_close  / stock2$price_close[1] * 100\np<-ggplot(stock1, aes(ref_date , price_close2, color=ticker))+\n        geom_line() +\n        geom_line(data=stock2) +\n        labs(x = \"\",\n             y='Closing prices', \n             title=\"Two assets returns, Initial price = 100\", \n             subtitle = \"Begin 01/01/2010\") +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python \n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nplt.close()\nstock1 = data[stocks[0]]\nstock2 = data[stocks[1]]\nstock1 = (stock1 / stock1.iloc[0]) * 100\nstock2 = (stock2 / stock2.iloc[0]) * 100\nfig, ax = plt.subplots()\nax.plot(stock1.index, stock1.values, label=stocks[0])\nax.plot(stock2.index, stock2.values, label=stocks[1])\nax.set_ylabel('Price')\nax.set_title('Two assets returns, Initial price = 100')\nax.legend()\nplt.show()\n```\n\n\n::: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\nLet's compute the average return of a portfolio with 40% invested in A and 60% in B. **The portfolio return is the average return of the assets**.\n\n::: {.panel-tabset}\n\n### R \n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\n# Defining weights and calculating portfolio return (daily)\nw <- c(0.40, 0.60)\n# Creating a df with stocks and weights\nw_tbl <- tibble(ticker = stocks,w = w)\n# Including the weights in the df prices (which contains the prices)\nprices  <- left_join(data ,w_tbl, by = 'ticker')\n# calculating the product of return times the portfolio weights for all days (this is necessary to calculate average return)\nprices$w_ret <- prices$ret_closing_prices * prices$w\n# Creating a dataframe with portfolio returns \nport_ret <- prices %>%\n  group_by(ref_date) %>%\n  summarise(port_ret = sum(w_ret))\n# Creating prices from the vector of returns\nport_ret$price_close2 <- cumprod(1+port_ret$port_ret) * 100\n# Graph with all returns\nport_ret$ticker <- 'Portfolio'\np <- ggplot(stock1, aes(ref_date , price_close2, color = ticker))+\n        geom_line() +geom_line(data=stock2) +geom_line(data=port_ret) +\n        labs(x = \"\",\n             y='Closing prices', \n             title=\"Two assets and Portfolio returns, Initial price = 100\", \n             subtitle = \"Begin 01/01/2010\") +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nplt.close()\nw = [0.40, 0.60]\n# Calculate the weighted returns for each stock\nreturns = data.pct_change().dropna()\nweighted_returns = returns.mul(w, axis=1)\n# Calculate the portfolio returns by taking the sum of the weighted returns\nportfolio_returns = weighted_returns.sum(axis=1)\n# Calculate the cumulative returns for each series\nstock_returns_cum = (1 + returns).cumprod() * 100\nportfolio_returns_cum = (1 + portfolio_returns).cumprod() * 100\n# Plot the results\nfig, ax = plt.subplots(figsize=(12, 6))\nax.plot(stock_returns_cum)\nax.plot(portfolio_returns_cum, label='Portfolio')\nax.set(title='Two assets and Portfolio returns, Initial price = 100', xlabel='', ylabel='Closing prices')\nax.legend()\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Covariance and Correlation**\n\nIf you don't remember how to calculate manually the correlation, please take a look at the notes of your statistics lectures.\n\n![](figs/bm_11_2.png)\n \n\n\n\n\n\n\n\n\n\n\n\n\n# 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n![](figs/bre13901_0713.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nThe variance of a three-asset portfolio can be built using a previous slide...\n\n$$var = (x_1^2 \\times \\sigma_1^2)  + (x_2^2 \\times \\sigma_2^2) + 2(x_1 \\times x_2 \\times \\sigma_1 \\times \\sigma_2 \\times \\rho_{12})$$\n\n... plus the following terms.\n\n$$+ (x_3^2 \\times \\sigma_3^2) + 2(x_1 \\times x_3 \\times \\sigma_1 \\times \\sigma_3 \\times \\rho_{13}) +  2(x_2 \\times x_3 \\times \\sigma_2 \\times \\sigma_3 \\times \\rho_{23})$$\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nNote in the previous figure: **as the number N of assets increases**, the number of **terms outside the main diagonal** increases more than the main diagonal.\n\n. . .\n\nTherefore, the **variance of a well-diversified portfolio mostly contains covariances**.\n\n. . . \n\nFor a portfolio with equal weights to all assets, We can write that:\n\n\n$$Var(R_p) = \\frac{1}{N} \\times average\\;variance + (1-\\frac{1}{N}) \\times average \\; covariance$$\n\n. . .\n\nAs N grows to infinite, only the average covariance lasts.\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nSo, if you **increase the size of your portfolio, the risk decreases** (until to a certain amount). \n\n**Usually, you can diversify about half of the initial variance.** \n\n![](figs/bm_fig_11_2.jpg) \n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large portfolio {.smaller background=\"#f5d5d5\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: false\nstart <-'2015-01-01' \nend   <-'2023-08-20'\n# Finding the tickers\ndata_temp <- yf_collection_get(\"IBOV\", first_date = start,last_date = end,freq_data = \"monthly\")\ntickers<-unique(data_temp$ticker)\ndf <- data_temp %>%  select(ref_date)  %>% distinct()\n# Now collecting data\nfor (i in 1:length(tickers)) {\ndata <- yf_get(tickers[[i]],first_date = start,last_date = end,freq_data = \"monthly\")\ndata <- data[complete.cases(data),] \ndata <- data %>%  select(ref_date, ret_closing_prices)\ncolnames(data) <- c(\"ref_date\",  tickers[[i]]  )\ndf <- merge(df,data,by=\"ref_date\")\n}\ndf$ref_date <- NULL\n# Setup to randomly combine \"j\" stocks and compute the standard deviation of this combination\nrows <- 1000\nfinal <- data.frame(matrix(NA,nrow = rows, ncol = length(tickers)))\nfor (j in 1:length(tickers) ) {\nfor (i in 1:rows ) {\ndf_r <- as.data.frame(df[, sample(  ncol(df) , j )])\ncov <- cov(df_r)\n# Var mean\nvar <- as.data.frame(diag(cov))\nvar_mean <- mean(var$`diag(cov)`)\n  #Covariance mean\n  if (j == 1) {\n  covar_mean <- var_mean\n  } else {\n  covar <- cov\n  diag(covar)=NA \n  covar[upper.tri(covar)] <- NA\n  covar<-c(covar)\n  covar_mean<- mean(covar,na.rm=TRUE)\n  }\n# Port Sd.\nvar_p <- (  (1/ j  * var_mean )   + (1- (1/j ) ) * covar_mean    ) ^ 0.5\nfinal[i,j] <- var_p\n}\n}\n# Computing the average of the \"i\" portfolios with \"j\" stocks \nsd   <- as.data.frame(colMeans(final))\nsd$N  <- seq_along(sd[,1])\np<- ggplot(sd, aes(y=`colMeans(final)` , x = N)) + geom_line() +\n        labs(x = \"Number of stocks (equal weight)\",\n             y='Standard deviation (monthly)', \n             title=\"Standard deviation of equally weighted portfolios\", \n             subtitle = \"01/01/2015-today (Brazilian stocks)\") +   theme_solarized()\nggplotly(p)\n```\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstart = '2015-01-01'\nend = pd.Timestamp.now()\nstocks = [\"ABEV3.SA\",\"ALPA4.SA\",\"AMER3.SA\",\"B3SA3.SA\",\"BBAS3.SA\",\"BBDC3.SA\",\"BBDC4.SA\",\"BEEF3.SA\",\"BPAN4.SA\",\"BRAP4.SA\",\"BRFS3.SA\",\"BRKM5.SA\",\"BRML3.SA\",\"CCRO3.SA\",\"CIEL3.SA\",\"CMIG4.SA\",\"COGN3.SA\",\"CPFE3.SA\",\"CPLE6.SA\",\"CSAN3.SA\",\"CSNA3.SA\",\"CYRE3.SA\",\"DXCO3.SA\",\"ECOR3.SA\",\"EGIE3.SA\",\"ELET3.SA\",\"ELET6.SA\",\"EMBR3.SA\",\"ENBR3.SA\",\"ENEV3.SA\",\"ENGI11.SA\",\"EQTL3.SA\",\"EZTC3.SA\",\"FLRY3.SA\",\"GGBR4.SA\",\"GOAU4.SA\",\"GOLL4.SA\",\"HYPE3.SA\",\"ITSA4.SA\",\"ITUB4.SA\",\"JBSS3.SA\",\"JHSF3.SA\",\"LREN3.SA\",\"MGLU3.SA\",\"MRFG3.SA\",\"MRVE3.SA\",\"MULT3.SA\",\"PCAR3.SA\",\"PETR3.SA\",\"PETR4.SA\",\"PRIO3.SA\",\"QUAL3.SA\",\"RADL3.SA\",\"RENT3.SA\",\"SANB11.SA\",\"SBSP3.SA\",\"SULA11.SA\",\"SUZB3.SA\",\"TAEE11.SA\",\"TIMS3.SA\",\"TOTS3.SA\",\"UGPA3.SA\",\"USIM5.SA\",\"VALE3.SA\",\"VIIA3.SA\",\"VIVT3.SA\",\"WEGE3.SA\",\"YDUQ3.SA\"]\ndata_temp = yf.download(stocks,start=start,end=end,interval='1mo', group_by='ticker')\ndf = data_temp.loc[:, (slice(None), 'Adj Close')].droplevel(level=1, axis=1)\ndf = df.pct_change()\nrows = 1000\nfinal = pd.DataFrame(np.empty((rows, len(data_temp))) * np.nan)\nfor j in range(len(stocks)):\n    for i in range(rows):\n        df_r = df.iloc[:, np.random.choice(df.shape[1], j+1, replace=False)]\n        cov = df_r.cov()\n        var = pd.DataFrame(np.diag(cov))\n        var_mean = var.mean().item()\n        if j == 0:\n            covar_mean = var_mean\n        else:\n            covar = cov.copy()\n            np.fill_diagonal(covar.values, np.nan)\n            covar = covar.where(np.triu(np.ones(covar.shape)).astype(np.bool_))\n            covar_mean = covar.stack().mean()\n        var_p = ((1/(j+1) * var_mean) + (1 - 1/(j+1)) * covar_mean) ** 0.5\n        final.iloc[i, j] = var_p\n# Computing the average of the \"i\" portfolios with \"j\" stocks \nsd = final.mean(axis=0).reset_index()\nsd = sd.rename(columns={'index': 'N', 0: 'colMeans(final)'})\nsd['N'] = sd['N'] + 1\n\nplt.close()\nplt.plot(sd['N'], sd['colMeans(final)'])\nplt.xlabel('Number of stocks (equal weight)')\nplt.ylabel('Standard deviation (monthly)')\nplt.title('Standard deviation of equally weighted portfolios')\nplt.suptitle('01/01/2015-today (Brazilian stocks)')\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nYou can also write that\n\n$$Var(R_p) = \\sum_i x_i \\times Cov(R_i,R_p)$$\n\nThis equation indicates that the variance of a portfolio is equal to the weighted average covariance of each stock **with the portfolio**.\n\n**This expression reveals that the risk of a portfolio depends on how each stock’s return moves in relation to it.**\n\nAdditionally, notice that stocks can have different weights in this equation (the previous example assumed equal weights).\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**Final equation**\n\nThe equation in the previous slide can also be written as (remember that $Cov = sd \\times sd \\times corr$):\n\n$$Var(R_p) = \\sum_i x_i \\times Sd(R_i) \\times Sd(R_p) \\times Corr(R_i,R_p)$$\n\nIf we divide both sides of this equation by $Sd(R_p)$, we find:\n\n$$Sd(R_p) = \\sum_i x_i \\times Sd(R_i)  \\times Corr(R_i,R_p)$$\n\nThis equation shows the amount of risk that each security brings to portfolio.\n\nEach asset *i* contributes to the portfolio's volatility according to its Sd scaled by its correlation with the portfolio.\n\n**Keep this equation in mind, we will use it in the future.**\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**More about correlation**. \n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.50\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.05)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\ndf <- df %>%  mutate(Condition = case_when(w1<0 ~ \"W1<0\" , w1>1 ~ \"W1>1\"  , 0<w1 | w1<1 ~ \"0<w1<1\" ))\nd1 <- df[df$w1 == 1, ]\nd2 <- df[df$w2 == 1, ]\np<-ggplot(df, aes(sdp, retp, color= Condition) ) + \n        geom_point(size=3)  +\n        labs(x = \"Standard deviation\",y='Expected return') +\n        xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n      geom_text(data = d1, aes(x=sd1+0.01, y=ret1-0.01, label = \"Asset 1\") , color = \"black\", hjust=0.2, vjust=0.75, size=4) +\n      geom_text(data = d2, aes(x=sd2-0.02, y=ret2-0.01, label = \"Asset 2\") , color = \"black\", hjust=0.1, vjust=0.75, size=4) +\n      ggtitle(paste(\"Correlation = \" , corr12)) +theme_solarized()\nggplotly(p)\n```\n\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n#data\ncorr12 = -0.50\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\n#weight \nw1 = np.arange(-0.4, 1.4, 0.05)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [\"portfolio\" + str(i+1) for i in range(len(w1))]\ndf = pd.DataFrame({'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp})\ndf['Condition'] = np.select(  [df['w1']<0, df['w1']>1, (df['w1']>0) & (df['w1']<1)], ['green', 'blue', 'red'])\n#Conditions to graph\nd1 = df[df['w1'] == 1]\nd2 = df[df['w2'] == 1]\n#Graph\nplt.close()\nfig, ax = plt.subplots()\nax.scatter(df['sdp'], df['retp'], c=df['Condition'], cmap='viridis')\nax.set(xlabel='Standard deviation', ylabel='Expected return', xlim=(0, max(sdp)), ylim=(0, max(retp)))\nax.set_title(\"Correlation = {}\".format(corr12))\nax.text(sd1+0.005,ret1-0.005, 'Asset 1', color='black', ha='left', va='center', fontsize=10)\nax.text(sd2+0.005,ret2+0.005, 'Asset 2', color='black', ha='left', va='center', fontsize=10)\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(ggpubr)\nlibrary(dplyr)\n# Create a vector of correlation values to loop through\ncorrs <- c(0.9, 0.5, 0, -0.5, -0.9, - 1)\n# Initialize an empty list to store plots\nplot_list <- list()\n# Loop through each correlation value and create a plot\nfor (corr12 in corrs) {\n  ret1 <- 0.175\n  sd1 <- 0.258\n  var1 <- sd1^2\n  ret2 <- 0.055\n  sd2 <- 0.115\n  var2 <- sd2^2\n  covar12 <- corr12*sd1*sd2\n  w1 <- seq(from=-0.4, to=1.4, by=0.05)\n  w2 <- 1 - w1\n  retp <- w1*ret1 + w2*ret2\n  varp <- w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\n  sdp <- sqrt(varp)\n  port.names <- paste(\"portfolio\", 1:length(w1), sep=\" \")\n  df <- data.frame(port.names, w1, w2, retp, sdp)\n  df <- df %>%  mutate(Condition = case_when(w1<0 ~ \"W1<0\" , w1>1 ~ \"W1>1\"  , 0<w1 | w1<1 ~ \"0<w1<1\" ))\n  d1 <- df[df$w1 == 1, ]\n  d2 <- df[df$w2 == 1, ]\n  plot <- ggplot(df, aes(sdp, retp, color= Condition) ) + \n    geom_point(size=2) +\n    labs(x = \"\",y=\"\")+\n    xlim(0, max(sdp)) + ylim(0, max(retp)) +\n    theme(legend.position = \"none\") +\n    theme()+\n    ggtitle(paste(\"Correlation = \" , corr12))\n  plot_list[[length(plot_list) + 1]] <- plot\n}\n# Arrange the plots in a 3x2 grid using ggarrange\nggarrange(plot_list[[1]], plot_list[[2]], plot_list[[3]],\n          plot_list[[4]], plot_list[[5]], plot_list[[6]],\n          nrow = 3, ncol = 2)\n```\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n#data\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\n#weight \nw1 = np.arange(-0.4, 1.4, 0.05)\nw2 = 1 - w1\n# create a list of correlation values\ncorr_values = [0.9, 0.5, 0, -0.5, -0.9, -1]\nplt.close()\n# create a 2x3 grid of subplots\nfig, axs = plt.subplots(2, 3, figsize=(20, 10))\n# loop through each correlation value and plot the corresponding scatter plot\nfor i, corr12 in enumerate(corr_values):\n    covar12 = corr12*sd1*sd2\n    retp = w1*ret1 + w2*ret2\n    varp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\n    sdp = np.sqrt(varp)\n    port_names = [\"portfolio\" + str(i+1) for i in range(len(w1))]\n    df = pd.DataFrame({'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp})\n    df['Condition'] = np.select([df['w1']<0, df['w1']>1, (df['w1']>0) & (df['w1']<1)], ['green', 'blue', 'red'])\n    d1 = df[df['w1'] == 1]\n    d2 = df[df['w2'] == 1]\n    ax = axs[i//3, i%3]  \n    ax.scatter(df['sdp'], df['retp'], c=df['Condition'], cmap='viridis')\n#    ax.set(xlabel='Standard deviation', ylabel='Expected return', xlim=(0, max(sdp)), ylim=(0, max(retp)))\n    ax.set_title(\"Correlation = {}\".format(corr12), fontsize=16)\n    ax.tick_params(labelsize=14)\n#    ax.set_xlabel('Standard deviation', fontsize=16)\n#    ax.set_ylabel('Expected return', fontsize=20)\nplt.tight_layout()  # adjust spacing between subplots\nplt.show()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**More about correlation**\n\nIn these graphs, I am assuming that you can invest a negative amount in a stock. This is called a **short position**. When you buy, you have a **long position**.\n\n**Short sales** are usually allowed if you provide enough security and collateral to the market. \n\nThe idea is that you think that a stock's price will go down so you sell it. Later, you buy it back (but if the price goes up, you lose part of your investment).\n\n**Notice that if you can short sale, you amplify the pairs return-risk available**.\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**Correlations usually positive**.\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstocks <-c(\"ITUB3.SA\", \"WEGE3.SA\", \"PETR3.SA\", \"VALE3.SA\", \"ITSA3.SA\" , \"BBAS3.SA\", \"ABEV3.SA\", \"GGBR4.SA\", \"LREN3.SA\", \"B3SA3.SA\", \"UGPA3.SA\", \"CSMG3.SA\", \"HYPE3.SA\") \nstart <-'2010-01-01' \nend   <- Sys.Date() \ndf <- yf_get(tickers = stocks[[1]], \n                         first_date = start,\n                         last_date = end,\n                         freq_data = \"monthly\")\ndf <- df %>%  select(ref_date)\n\nfor (i in 1:length(stocks)) {\ndata <- yf_get(tickers = stocks[[i]], \n                         first_date = start,\n                         last_date = end,\n                         freq_data = \"monthly\")\ndata<-data[complete.cases(data),] \ndata<- data %>%  select(ref_date, ret_adjusted_prices)\ncolnames(data) <- c(\"ref_date\",  stocks[[i]]  )\ndf <- merge(df,data,by=\"ref_date\")\n}\ndf$ref_date <-NULL\ncor<- cor(df, method = c(\"pearson\"))\nlibrary(corrplot)\ncorrplot(cor,method = 'number' ,  tl.col = \"black\",   tl.cex = 0.9,  col = COL1('Reds') , number.cex = 0.8)\n```\n\n\n\n\n\n\n\n\n\n### Python\n\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstocks = [\"ITUB3.SA\", \"WEGE3.SA\", \"PETR3.SA\", \"VALE3.SA\", \"ITSA3.SA\", \"BBAS3.SA\", \"ABEV3.SA\", \"GGBR4.SA\", \"LREN3.SA\", \"B3SA3.SA\", \"UGPA3.SA\", \"CSMG3.SA\", \"HYPE3.SA\"]\nstart = '2010-01-01'\nend = pd.Timestamp.now()\ndf = yf.download(stocks[0], start=start, end=end, interval=\"1mo\")[[\"Adj Close\"]]\ndf.columns = [stocks[0]]\nfor stock in stocks[1:]:\n    data = yf.download(stock, start=start, end=end, interval=\"1mo\")[[\"Adj Close\"]]\n    data.columns = [stock]\n    df = df.merge(data, how=\"inner\", on=\"Date\")\ndf = df.ffill()  # forward-fill missing values\ncor = df.corr(method=\"pearson\")\nsns.heatmap(cor, annot=True, fmt=\".2f\", cmap=\"Reds\", annot_kws={\"fontsize\":20})\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\nNow, you can understand what an **efficient portfolio** is.\n\n- It is the portfolio that brings the **higher return for any given level of risk**\n- or a portfolio that brings the **lower risk for any given return**.\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\nw1_min = round((var2 - covar12)/(var1 + var2 - 2*covar12), digits = 1)\nw2_min = 1 - w1_min\nd_min <- df[w2_min <= df$w2, ]\nd_min <- data.frame(d_min[ nrow(d_min) ,])\ndf <- df %>%  mutate(Efficient = case_when(w2<=w2_min ~ \"Efficient\" , w2>w2_min ~ \"Not Efficient\" ))\np<-ggplot(df, aes(sdp, retp, color = Efficient) ) + \n        geom_point(size=1)  +\n        labs(x = \"Standard deviation\",y='Expected return') +\n        xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n      geom_text(data = d_min, aes(x=sd1+0.01, y=ret1-0.01, label = \"Asset 1\") , hjust = -0.1, color = \"black\", size=4)  +   \n      geom_text(data = d_min, aes(x=sd2-0.02, y=ret2-0.01, label = \"Asset 2\") , hjust = -0.1, color = \"black\", size=4)  +   \n      geom_text(data = d_min, aes(x=sdp+0.06, y=retp, label = \"Minimum variance portfolio\") , hjust = -0.1, color = \"black\", size=4)  +   \n      theme_solarized()\nggplotly(p)\n```\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n# Set up variables\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\nw1 = np.arange(-0.4, 1.41, 0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [f\"portfolio {i+1}\" for i in range(len(w1))]\ndata = {'port_names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp}\ndf = pd.DataFrame(data)\nw1_min = round((var2 - covar12)/(var1 + var2 - 2*covar12), 1)\nw2_min = 1 - w1_min\nd_min = df.loc[df['w2'] >= w2_min, :]\nd_min = pd.DataFrame(d_min.iloc[-1, :]).T\ndf['Efficient'] = np.where(df['w2'] <= w2_min, 'Efficient', 'Not Efficient')\n# Plotting\nfig, ax = plt.subplots(figsize=(20, 10))\ncolors = {'Efficient': '#dc322f', 'Not Efficient': '#2aa198'}\nfor label, color in colors.items():\n    mask = df['Efficient'] == label\n    ax.scatter(df.loc[mask, 'sdp'], df.loc[mask, 'retp'], c=color, label=label, alpha=0.7, s=50)\nax.set_xlabel('Standard deviation', fontsize=25)\nax.set_ylabel('Expected return', fontsize=25)\nax.set_xlim(0, max(sdp))\nax.set_ylim(0, max(retp))\nax.text(sd1+0.01,ret1, 'Asset 1', color='black', ha='left', va='center', fontsize=20)\nax.text(sd2+0.01,ret2, 'Asset 2', color='black', ha='left', va='center', fontsize=20)\nax.text(sd2-0.01,ret2+0.02, 'Minimum Variance Portfolio', color='black', ha='left', va='center', fontsize=20)\nax.legend(fontsize=20)\nax.tick_params(axis='both', which='major', labelsize=20, color='#839496', length=8, width=1.5)\nplt.grid(color='#657b83', linestyle='--', linewidth=0.5, alpha=0.5)\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n**Example with real data**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(yfR)\nlibrary(kableExtra)\nstart <-'2010-01-01' \nend   <-Sys.Date()  \nfreq_data <-  'monthly'\nticker1 <- 'BBDC3.SA'\nticker2 <- 'PETR3.SA'\nasset1 <- yf_get(tickers = ticker1, first_date = start,last_date = end,freq_data = freq_data)\nasset2 <- yf_get(tickers = ticker2, first_date = start,last_date = end,freq_data = freq_data)\nasset1<-asset1[complete.cases(asset1),] \nasset2<-asset2[complete.cases(asset2),] \ner_1 <- mean(asset1$ret_adjusted_prices) \ner_2 <- mean(asset2$ret_adjusted_prices)\nsd_1 <- sd(asset1$ret_adjusted_prices) \nsd_2 <- sd(asset2$ret_adjusted_prices) \ntable <- data.frame(\"Ticker\" = c(ticker1 , ticker2), \n                 \"ER\" = c(er_1* 100 , er_2* 100), \n                 \"SD\" = c(sd_1* 100, sd_2* 100)) \nkable(table,col.names = c(\"Ticker\", \"Expected Return\", \"Standard Deviation\"), \n            align = c(\"l\", \"r\", \"r\"), \n            format.args = list(big.mark = \",\", decimal.mark = \".\", scientific = FALSE), \n            caption = \"Summary statistics (monthly returns since 2010)\") %>%\n  kable_styling(bootstrap_options = \"striped\")\n```\n\n\n\n\n\n### Python\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\np<-ggplot(table, aes(x = SD, y = ER, color = Ticker)) +\n      geom_point(size = 4) +\n      theme_bw() + \n      ggtitle(\"Risk-Return Tradeoff, 2010 to 2023.\") +\n      xlab(\"Standard deviation\") + ylab(\"Expected Return\") +\n      scale_y_continuous( limits = c(min(table$ER)*0.95, max(table$ER)*1.05)) +\n      scale_x_continuous( limits = c(min(table$SD)*0.95, max(table$SD)*1.05))+   theme_solarized()\nggplotly(p)\n```\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(data.table)\ncov_12 <- cov(asset1$ret_adjusted_prices, asset2$ret_adjusted_prices)\ncorr_12 <- cor(asset1$ret_adjusted_prices, asset2$ret_adjusted_prices)\nweights <- seq(from = 0, to = 1, length.out = 1000)\ntwo_assets <- data.table(w1 = weights ,w2 = 1 - weights)\n# calculate the expected returns and standard deviations for the 1000 possible portfolios\ntwo_assets[, ':=' (er_p = w1 * er_1 + w2 * er_2,\n                   sd_p = sqrt(w1^2 * sd_1^2 +w2^2 * sd_2^2 +2 * w1 * w2 * cov_12))]\np<-ggplot() +\ngeom_point(data = two_assets, aes(x = sd_p, y = er_p, color = w1)) +\ngeom_point(data = data.table(sd = c(sd_1, sd_2), mean = c(er_1, er_2)),\naes(x = sd, y = mean), color = \"red\", size = 3, shape = 18) +\ntheme_bw() + ggtitle(\"Possible Portfolios with Two Risky Assets\") +\nxlab(\"Standard deviation\") + ylab(\"Expected Return\") +\n      scale_y_continuous( limits = c(min(two_assets$er_p)*0.99, max(two_assets$er_p)*1.01)) +\n      scale_x_continuous( limits = c(min(two_assets$sd_p)*0.9, max(two_assets$sd_p)*1.1)) +   theme_solarized() +scale_color_continuous(name = \"W. Asset 1\")\nggplotly(p)\n```\n\n\n\n\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstart = '2010-01-01'\nend = pd.to_datetime('today')\nfreq_data = '1mo'\nticker1 = 'BBDC3.SA'\nticker2 = 'PETR3.SA'\nasset1 = yf.download(ticker1, start=start, end=end, interval=freq_data)['Adj Close']\nasset2 = yf.download(ticker2, start=start, end=end, interval=freq_data)['Adj Close']\nasset1 = asset1.dropna()\nasset2 = asset2.dropna()\ner_1 = np.mean(asset1.pct_change().dropna()) * 12\ner_2 = np.mean(asset2.pct_change().dropna()) * 12\nsd_1 = np.std(asset1.pct_change().dropna()) * np.sqrt(12)\nsd_2 = np.std(asset2.pct_change().dropna()) * np.sqrt(12)\ncov_12 = np.cov(asset1.pct_change().dropna(), asset2.pct_change().dropna())[0, 1]\ncorr_12 = np.corrcoef(asset1.pct_change().dropna(), asset2.pct_change().dropna())[0, 1]\nweights = np.linspace(0, 1, 1000)\ntwo_assets = pd.DataFrame({'w1': weights, 'w2': 1 - weights})\ntwo_assets['er_p'] = two_assets['w1'] * er_1 + two_assets['w2'] * er_2\ntwo_assets['sd_p'] = np.sqrt(two_assets['w1']**2 * sd_1**2 + two_assets['w2']**2 * sd_2**2 + 2 * two_assets['w1'] * two_assets['w2'] * cov_12)\nplt.close()\nplt.figure(figsize=(20,10))\nplt.scatter(two_assets['sd_p'], two_assets['er_p'], c=two_assets['w1'])\nplt.scatter(sd_1, er_1, color='red', marker='s', s=100)\nplt.scatter(sd_2, er_2, color='red', marker='s', s=100)\nplt.title('Possible Portfolios with Two Risky Assets',fontsize=25)\nplt.xlabel('Standard deviation',fontsize=22)\nplt.ylabel('Expected Return',fontsize=22)\nplt.xlim(min(two_assets['sd_p']) * 0.9, max(two_assets['sd_p']) * 1.1)\nplt.ylim(min(two_assets['er_p']) * 0.99, max(two_assets['er_p']) * 1.01)\nplt.colorbar(label=r'$Weight\\;Asset\\;1$')\nax.tick_params(axis='both', which='major', labelsize=18)\nplt.show()\n```\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\nAs a financial manager, one crucial job you have is to find the **efficient portfolios** and the **minimum variance portfolio**.\n\n![](figs/bm_11_4.png)\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n**If you add stocks you improve the frontier**\n\nWhen you combine several assets, you will have what is called **efficient frontier**.\n\n![](figs/bm_11_8.png)\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n**The frontier is not so clear here**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstart <-'2010-01-01' \nend   <- '2023-01-01'\nfreq_data <- \"yearly\"\ndf <- yf_collection_get(\"IBOV\", \n                         first_date = start,\n                         last_date = end,\n                         freq_data = freq_data)\nstocks <- unique(df$ticker)\ndf <- df %>%  select(ref_date)\n\nfor (i in 1:length(stocks)) {\ndata <- yf_get(tickers = stocks[[i]], \n                         first_date = start,\n                         last_date = end,\n                         freq_data = freq_data)\ndata<-data[complete.cases(data),] \ndata<- data %>%  select(ref_date, ret_closing_prices)\ncolnames(data) <- c(\"ref_date\",  stocks[[i]]  )\ndf <- merge(df,data,by=\"ref_date\")\n}\n\ndup <- duplicated(df)\ndf <- unique(df[!dup,])\n\ndf$ref_date <-NULL\nret <- as.vector(colMeans(df))\ncov <- cov(df)\n\n# Random numbers to create the frontier\nset.seed(100)\nint <- 10000\nw<- data.frame((replicate(length(stocks),sample(int,rep=TRUE)) / int ))\nw$sum <-  rowSums(w)\ncolnames(w) <- c(stocks, 'Sum')\nfor (i in 1:int) {\nw[i, 1:length(stocks)] <- w[i, 1:length(stocks)] / w[i, ncol(w)]\n}\n\nw$Sum <- NULL\n# creating final dataframe\nport <- data.frame(matrix(NA,nrow = int,ncol = 2))\ncolnames(port) <- c(\"Return\", \"Sd\")\nfor (i in 1:int) {\nport[i,1] <- sum(  w[i, ] * ret)\nport[i,2] <- sqrt( as.matrix(w[i, ]) %*% as.matrix(cov) %*% as.matrix(t(w[i, ]) )) \n}\n#ggplot\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        theme_solarized() + \n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int , \"random portfolios - All Ibov (2010-2023, yearly returns)\") )\nggplotly(p)\n```\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: false\n#| results: false\n#| output: false\n#| code-fold: true\n#| code-line-numbers: false\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nstart = '2010-01-01'\nend = '2023-01-01'\nfreq_data = '1mo'\n#stocks = r.yf_collection_get(\"IBOV\", first_date = start,last_date = end,freq_data = \"yearly\")\nstocks = [\"ABEV3.SA\",\"ALPA4.SA\",\"AMER3.SA\",\"B3SA3.SA\",\"BBAS3.SA\",\"BBDC3.SA\",\"BBDC4.SA\",\"BEEF3.SA\",\"BPAN4.SA\",\"BRAP4.SA\",\"BRFS3.SA\",\"BRKM5.SA\",\"BRML3.SA\",\"CCRO3.SA\",\"CIEL3.SA\",\"CMIG4.SA\",\"COGN3.SA\",\"CPFE3.SA\",\"CPLE6.SA\",\"CSAN3.SA\",\"CSNA3.SA\",\"CYRE3.SA\",\"DXCO3.SA\",\"ECOR3.SA\",\"EGIE3.SA\",\"ELET3.SA\",\"ELET6.SA\",\"EMBR3.SA\",\"ENBR3.SA\",\"ENEV3.SA\",\"ENGI11.SA\",\"EQTL3.SA\",\"EZTC3.SA\",\"FLRY3.SA\",\"GGBR4.SA\",\"GOAU4.SA\",\"GOLL4.SA\",\"HYPE3.SA\",\"ITSA4.SA\",\"ITUB4.SA\",\"JBSS3.SA\",\"JHSF3.SA\",\"LREN3.SA\",\"MGLU3.SA\",\"MRFG3.SA\",\"MRVE3.SA\",\"MULT3.SA\",\"PCAR3.SA\",\"PETR3.SA\",\"PETR4.SA\",\"PRIO3.SA\",\"QUAL3.SA\",\"RADL3.SA\",\"RENT3.SA\",\"SANB11.SA\",\"SBSP3.SA\",\"SULA11.SA\",\"SUZB3.SA\",\"TAEE11.SA\",\"TIMS3.SA\",\"TOTS3.SA\",\"UGPA3.SA\",\"USIM5.SA\",\"VALE3.SA\",\"VIIA3.SA\",\"VIVT3.SA\",\"WEGE3.SA\",\"YDUQ3.SA\"]\ndf = yf.download(stocks, start=start, end=end, interval=freq_data)[['Adj Close']]\ndf = df.reset_index()[['Date']]\nfor stock in stocks:\n    data = yf.download(stock, start=start, end=end, interval=freq_data)\n    data = data.dropna() \n    data = data[['Adj Close']]\n    data.columns = [stock]\n    df = pd.merge(df, data, on='Date', how='outer')\n\ndf = df.drop(df.columns[[0,1]], axis=1)\n#Return and covariance calculation\nret = df.pct_change().mean(axis=0)\nret_m = df.pct_change()\ncov = ret_m.cov()\n\n# Random numbers to create the frontier\nnp.random.seed(100)\nint_ = 10000\nw = np.random.randint(0, int_+1, size=(int_, len(stocks))) / int_\nw = w / np.sum(w, axis=1, keepdims=True)\n# creating final dataframe\nport = pd.DataFrame(np.zeros((int_, 2)), columns=[\"Return\", \"Sd\"])\ncov_array = cov.values  # Convert covariance matrix to NumPy array\nfor i in range(int_):\n    port.iloc[i, 0] = np.sum(w[i, :len(stocks)] * ret)\n    port.iloc[i, 1] = np.sqrt(np.matmul(np.matmul(w[i, :], cov_array), w[i, :].T))\n    \n#plot\nplt.close()\nplt.figure(figsize=(20,10))\nplt.scatter(port['Sd'], port['Return'], alpha=0.5, color=\"darkblue\", s=50)\nplt.xlabel('Standard deviation', fontsize=25)\nplt.ylabel('Expected Return', fontsize=25)\nax.tick_params(axis='both', which='major', labelsize=18)\nplt.title(str(int_) + ' random portfolios - All Ibov (2010-2023, monthly returns)' , fontsize=25)\nplt.show()\n```\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n# 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nThus far, we have considered the risk and return possibilities that result from combining risky investments into portfolios. \n\nBy including all risky investments in the construction of the efficient frontier, we achieve **the maximum diversification possible with risky assets**.\n\nNow, let's see what happens when you **combine a portfolio of risky assets with the risk free asset.**\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nThe return is:\n\n$$E[R_{px}] =  x \\times E[R_p] + (1-x) \\times R_f $$\n\n$x$ is the weight invested in the portfolio:\n\n. . .\n\nWhich leads to:\n\n$$E[R_{px}] =  x \\times E[R_p] + R_f - x \\times R_f $$\n\n$$E[R_{px}] =  R_f + x \\times ( E[R_p] - R_f ) $$\n\nThe second equation shows that: **The expected return is equal to the risk-free rate plus a fraction of the portfolio’s risk premium, $E[R_p] - R_f$, based on the fraction x that we invest in it.**\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nRemember that the risk free rate is assumed to have no risk, thus no variance. The standard deviation is:\n\n- $$Sd(R_{px}) = \\sqrt{(1-x)^2 \\times Var(R_f) + x^2 \\times Var(R_p)  + 2 \\times(1-x) \\times x \\times Cov(R_f, R_p)}$$\n\nWhich leads to\n\n$$Sd(R_{px}) = \\sqrt{x^2 \\times Var(R_p)}$$\n\n$$Sd(R_{px}) = x \\times Sd(R_p)$$\n\nThat is, the volatility is only a fraction of the volatility of the portfolio, based on the amount we invest in it.\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n**Combine an asset with the Rf rate**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\nrf = 0.03\n#asset 1\nw1    = seq(from=0, to=1.4, by=0.01)\nwrf1   = 1 - w1\nretp1 = wrf1 * rf + w1 * ret1\nsdp1  = w1*sd1\n#asset2 \nw2    = seq(from=0, to=1.4, by=0.02)\nwrf2   = 1 - w2\nretp2 = wrf2 * rf + w2 * ret2\nsdp2  = w2*sd2\n#dfs\ndf1 <- data.frame(w1, retp1, sdp1)\ndf2 <- data.frame(w2, retp2, sdp2)\nd1 <- df1[df1$w1 == 1, ]\nd2 <- df2[df2$w2 == 1, ]\n#ggplot\np<-ggplot() +  \n  geom_point(data=df1, aes(x=sdp1, y=retp1, color=ifelse(w1>1,\"blue\",\"lightblue\")), size=1, show.legend = FALSE) +\n  geom_point(data=df2, aes(x=sdp2, y=retp2, color=ifelse(w2>1,\"red\",\"pink\")), size=1, show.legend = FALSE) +\n  labs(x = \"Standard deviation\",y='Expected return', title = \"Risk and Return of two assets combined with the Risk-Free Rate\" ) +\n  xlim(0, max(sdp1)) + ylim(0, max(retp1) ) +\n  geom_text(data = d1, aes(x=sdp1, y=retp1-0.01, label = \"Asset 1\") , color = \"black\", hjust=0.2, vjust=0.75, size=4) +\n  geom_text(data = d2, aes(x=sdp2, y=retp2-0.01, label = \"Asset 2\") , color = \"black\", hjust=0.1, vjust=0.75, size=4) +\n  geom_text(data = as.data.frame(rf), aes(x=0.02, y=rf-0.01, label = \"Risk-free\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +   \n  scale_color_identity() + \n  theme_solarized()\nggplotly(p)\n```\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n\nplt.close()\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\nrf = 0.03\n#asset 1\nw1 = np.arange(0, 1.4, 0.01)\nwrf1 = 1 - w1\nretp1 = wrf1 * rf + w1 * ret1\nsdp1 = w1 * sd1\n#asset2 \nw2 = np.arange(0, 1.4, 0.02)\nwrf2 = 1 - w2\nretp2 = wrf2 * rf + w2 * ret2\nsdp2 = w2 * sd2\n#dfs\ndf1 = np.column_stack((w1, retp1, sdp1))\ndf2 = np.column_stack((w2, retp2, sdp2))\nd1 = df1[df1[:, 0] == 1, :]\nd2 = df2[df2[:, 0] == 1, :]\n#plot\nplt.figure(figsize=(10, 6))\nplt.scatter(sdp1, retp1, c=np.where(w1>1, 'blue', 'lightblue'), s=15, edgecolors='none')\nplt.scatter(sdp2, retp2, c=np.where(w2>1, 'red', 'pink'), s=15, edgecolors='none')\nplt.plot(d1[0, 2], d1[0, 1], 'ko', markersize=5)\nplt.plot(d2[0, 2], d2[0, 1], 'ko', markersize=5)\nplt.annotate('Asset 1', xy=(d1[0, 2], d1[0, 1]), xytext=(d1[0, 2], d1[0, 1]-0.01), color='black', fontsize=10)\nplt.annotate('Asset 2', xy=(d2[0, 2], d2[0, 1]), xytext=(d2[0, 2], d2[0, 1]-0.01), color='black', fontsize=10)\nplt.annotate('Risk-free',  xy=(0.015, rf-0.01), xytext=(0.01, rf-0.01), color='black', fontsize=10)\nplt.xlabel('Standard deviation', fontsize=15)\nplt.ylabel('Expected return', fontsize=15)\nplt.title('Risk and Return of two assets combined with the Risk-Free Rate', fontsize=15)\nplt.xlim(0, sdp1.max())\nplt.ylim(0, retp1.max())\nplt.show()\n```\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nRemember that **we have several potential combinations between Assets 1 and 2**. \n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\nd1 <- df[df$w1 == 1, ]\nd2 <- df[df$w2 == 1, ]\ndf1 <- data.frame(w1, retp, sdp)\nrf = 0.03\nwrf1   = 1 - w1\nwrf2   = 1 - w2\nretp1  = wrf1 * rf + w1 * ret1\nsdp1   = w1*sd1\nretp2  = wrf2 * rf + w2 * ret2\nsdp2   = w2*sd2\n\np <- ggplot() +\n  geom_point(data=df, aes(x=sdp, y=retp, color=ifelse(w1>1,\"red\" ,ifelse(w1<0,\"grey\",\"pink\"))), size=1, show.legend = FALSE) +\n  geom_point(data=df1,aes(x=sdp1,y=retp1,color=ifelse(w1>1,'blue','lightblue')), size=1, show.legend = FALSE) +\n            geom_point()  +\n            labs(x = \"Standard deviation\",y='Expected return', title = \"Combinations of Risk and Return of two assets and the Risk-Free Rate\" ) +\n            xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n            geom_text(data = d1, aes(x=sdp+0.015, y=retp-0.01, label = \"Asset 1\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = d2, aes(x=sdp+0.035, y=retp, label = \"Asset 2\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = as.data.frame(rf), aes(x=0.02, y=rf-0.01, label = \"Risk-free\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +            theme_solarized()+scale_color_identity()\nggplotly(p)\n```\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\nw1 = np.arange(-0.4, 1.41, 0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [f\"portfolio{i+1}\" for i in range(len(w1))]\ndf = {'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp}\ndf = pd.DataFrame(df)\nd1 = df[df['w1'] == 1]\nd2 = df[df['w2'] == 1]\nrf = 0.03\nwrf1   = 1 - w1\nwrf2   = 1 - w2\nretp1  = wrf1 * rf + w1 * ret1\nsdp1   = w1*sd1\nretp2  = wrf2 * rf + w2 * ret2\nsdp2   = w2*sd2\n#plot\nplt.close()\nfig, ax = plt.subplots()\nscatter1 = ax.scatter(df['sdp'], df['retp'], s=3, c=np.where(df['w1'] > 1, 'red', np.where(df['w1'] < 0, 'grey', 'pink')))\nscatter2 = ax.scatter(sdp1, retp1, s=3, c=np.where(df['w1'] > 1, 'blue', 'lightblue'))\nplt.xlim(0, max(df['sdp']))\nplt.ylim(0, max(df['retp']))\nplt.xlabel('Standard deviation',fontsize=12)\nplt.ylabel('Expected return',fontsize=12)\nax.text(0.005, 0.025, 'Risk-free', color='black', ha='left', va='center', fontsize=10)\nax.text(sd1+0.01,ret1, 'Asset 1', color='black', ha='left', va='center', fontsize=10)\nax.text(sd2+0.01,ret2, 'Asset 2', color='black', ha='left', va='center', fontsize=10)\nplt.title('Combinations of Risk and Return of two assets and the Risk-Free Rate', fontsize=15)\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nIn this situation, we are better off investing in the **Tangent portfolio**, then \"moving\" to adjust the level of risk.\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\nd1 <- df[df$w1 == 1, ]\nd2 <- df[df$w2 == 1, ]\ndf1 <- data.frame(w1, retp, sdp)\n# Including risk free rate\nrf = 0.03\nwrf1   = 1 - w1\nwrf2   = 1 - w2\nretp1  = wrf1 * rf + w1 * ret1\nsdp1   = w1*sd1\nretp2  = wrf2 * rf + w2 * ret2\nsdp2   = w2*sd2\ndfrf1 <- data.frame(w1, retp1, sdp1)\n# Tangent portfolio\ntop = (ret1 - rf)*var2 - (ret2 - rf)*covar12\nbot = (ret1 - rf)*var2 + (ret2 - rf)*var1 - (ret1 - rf + ret2 - rf)*covar12\nw1_t = top/bot\nw2_t = 1 - w1_t\nretp_t = w1_t*ret1 + w2_t*ret2\nvarp_t = w1_t^2 * var1 + w2_t^2 * var2 + 2*w1_t*w2_t*covar12\nsdp_t = sqrt(varp_t)\ntan = (retp_t - rf)/sdp_t\ndft <- data.frame(w1_t, retp_t, sdp_t)\n# exploding tangent line\nwt    = seq(from=0, to=2, by=0.01)\nwrft   = 1 - wt\nretpt = wrft * rf + wt * retp_t\nsdpt  = wt*sdp_t\ndft <- data.frame(wt, retpt, sdpt)\ndft1 <- dft[dft$w1 == 1, ]\n\np <- ggplot() +\n  geom_point(data=df, aes(x=sdp, y=retp, color=ifelse(w1>1,\"red\" ,ifelse(w1<0,\"grey\",\"pink\"))), size=1, show.legend = FALSE) +\n            geom_point(data=dfrf1,aes(x=sdp1,y=retp1,color=ifelse(w1>1,'blue','lightblue')), size=1, show.legend = FALSE) +\n            geom_point(data=dft  ,aes(x=sdpt,y=retpt,color=ifelse(wt>1,'darkgreen','lightgreen')), size=1, show.legend = FALSE) +\n            geom_point(size=1)  +\n            labs(x = \"Standard deviation\",y='Expected return', title = \"Efficient frontier and the tanget portfolio\" ) +\n            xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n            geom_text(data = d1, aes(x=sdp+0.015, y=retp-0.01, label = \"Asset 1\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = d2, aes(x=sdp+0.035, y=retp, label = \"Asset 2\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = dft, aes(x=sdp_t-0.04, y=retp_t, label = \"Tanget Port.\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = as.data.frame(rf), aes(x=0.02, y=rf-0.01, label = \"Risk-free\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +            theme_solarized()+\n        scale_color_identity()\nggplotly(p)\n```\n\n\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\nw1 = np.arange(-0.4, 1.41, 0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [f\"portfolio {i+1}\" for i in range(len(w1))]\ndf = pd.DataFrame({'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp})\nd1 = df[df['w1'] == 1]\nd2 = df[df['w2'] == 1]\ndf1 = df[['w1', 'retp', 'sdp']]\n\n# Including risk free rate\nrf = 0.03\nwrf1 = 1 - w1\nwrf2 = 1 - w2\nretp1 = wrf1 * rf + w1 * ret1\nsdp1 = w1*sd1\nretp2 = wrf2 * rf + w2 * ret2\nsdp2 = w2*sd2\ndfrf1 = np.column_stack((w1, retp1, sdp1))\n# Tangent portfolio\ntop = (ret1 - rf)*var2 - (ret2 - rf)*covar12\nbot = (ret1 - rf)*var2 + (ret2 - rf)*var1 - (ret1 - rf + ret2 - rf)*covar12\nw1_t = top/bot\nw2_t = 1 - w1_t\nretp_t = w1_t*ret1 + w2_t*ret2\nvarp_t = w1_t**2 * var1 + w2_t**2 * var2 + 2*w1_t*w2_t*covar12\nsdp_t = np.sqrt(varp_t)\ntan = (retp_t - rf)/sdp_t\ndft = np.column_stack((w1_t, retp_t, sdp_t))\n# exploding tangent line\nwt = np.arange(0, 2.01, 0.01)\nwrft = 1 - wt\nretpt = wrft * rf + wt * retp_t\nsdpt = wt*sdp_t\ndft = np.column_stack((wt, retpt, sdpt))\ndft1 = dft[dft[:, 0] == 1, :]\ndft = pd.DataFrame(dft)\ndft = {'wt': wt, 'retpt': retpt, 'sdpt': sdpt}\n\n#plot\nplt.close()\nfig, ax = plt.subplots()\nscatter1 = ax.scatter(df['sdp'], df['retp'], s=3, c=np.where(df['w1'] > 1, 'red', np.where(df['w1'] < 0, 'grey', 'pink')))\nscatter2 = ax.scatter(sdp1, retp1, s=3, c=np.where(df['w1'] > 1, 'blue', 'lightblue'))\nscatter3 = ax.scatter(dft['sdpt'], dft['retpt'], s=3, c=np.where(dft['wt']>1,'darkgreen','lightgreen'))\nplt.xlim(0, max(df['sdp']))\nplt.ylim(0, max(df['retp']))\nplt.xlabel('Standard deviation',fontsize=15)\nplt.ylabel('Expected return',fontsize=15)\nplt.title('Efficient frontier and the tanget portfolio',fontsize=20)\nax.text(0.005, 0.025, 'Risk-free', color='black', ha='left', va='center', fontsize=12)\nax.text(sd1+0.01,ret1, 'Asset 1', color='black', ha='left', va='center', fontsize=12)\nax.text(sd2+0.01,ret2, 'Asset 2', color='black', ha='left', va='center', fontsize=12)\nax.text(sdp_t-0.07,retp_t, 'Tangent Port.', color='black', ha='left', va='center', fontsize=12)\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nRemember that you can have **short positions**:\n\nIf you borrow at the Rf to invest in a portfolio, you have a levered position. \n\nYou are investing more than 100% of your funds in the portolio. The weight is higher than 1.\n\nThe book calls this **buying stocks on margin**.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nTo identify the tangent portfolio, we compute the Sharpe ratio. \n\n$$Sharpe\\;ratio = \\frac{E[R_p]-R_f}{Sd(R_p)}$$\n\nTo earn the highest possible expected return for any level of volatility we must find the portfolio that generates the steepest (highest inclination) possible line when combined with the risk-free investment.\n\n. . .\n\nThe **optimal portfolio to combine with the risk-free asset will be the one with the highest Sharpe ratio**, where the line with the risk-free investment **just touches, and so is tangent** to, the efficient frontier of risky investments\n\n. . .\n\nThe Sharpe ratio measures the ratio of **reward-to-volatility** provided by a portfolio. \n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n**Fact 1:** The tangent portfolio is **efficient**.\n\n. . .\n\n**Fact 2:** Once we include the risk-free investment, all efficient portfolios are combinations of the risk-free investment and the tangent portfolio.\n\n. . .\n\nAll investors should have the tangent portfolio. All investors should combine the tangent portfolio with the risk free asset to adjust the level of risk.\n\n. . .\n\nIf you ignore the risk free asset, you have several efficient portfolios (**efficient frontier**). **But once you combine with the risk free rate, there is only one.** \n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n**What is a good Sharpe Ratio?**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nport$rf <- 0.1\nport$sharpe <- (port$Return - port$rf) / port$Sd\np<-ggplot(port, aes(x=sharpe)) + \n        geom_histogram(alpha=0.2) + \n        theme_solarized() + \n        xlab(\"Sharpe\") + ylab(\"Number of portfolios\") + \n        labs(title = paste(int , \"random portfolios - All Ibov (2010-2023, yearly returns, Rf = 0.10)\") )\nggplotly(p)\n```\n\n\n### Python\n\n::: {.callout-important}\n\n**The following code uses monthly returns instead of annual.** \n\n:::\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nport['rf'] = 0.01 # using 1% of RF per month\nport['sharpe'] = (port['Return'] - port['rf']) / port['Sd']\n# Plot histogram\nplt.close()\nplt.hist(port['sharpe'], alpha=0.5)\nplt.xlabel('Sharpe',fontsize=15)\nplt.ylabel('Number of portfolios',fontsize=15)\nplt.title(str(int_) + ' random portfolios - All Ibov (2010-2023, monthly returns)' , fontsize=25)\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nLet's now consider how much **return we will demand from a risky asset** in order to make its inclusion in our portfolio worthy.\n\nLet's say that **you hold an arbitrary portfolio P** (it does not matter what is inside P for the moment).\n\nYou only include an additional asset if it **excess return to the level of risk**, right? That is, if it **increases the Sharpe ratio** of the resulting portfolio (Portfolio P + New asset)\n\n. . . \n\nWhat is the excess return that this asset *i* brings to your portfolio P?\n\n- $E[R_i] - R_f$ (quite simple!)\n\n. . .\n\nWhat is the risk that this asset *i* brings to your portfolio P?\n\n- It is $Sd(R_i) \\times corr(R_i,R_p)$\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nSo now our question is: **Is the gain in return from investing in *i* adequate to make up for the increase in risk?**\n\n. . .\n\nTo see that, we have to test if (because the right-hand part is the level of return-to-risk we already have in P). \n\n$$\\frac{E[R_i] - R_f}{Sd(R_i) \\times corr(R_i,R_p)} > \\frac{E[R_p] - R_f}{Sd(R_p)}$$\n\nMoving the denominator to the right-hand side:  \n\n$$E[R_i] - R_f > Sd(R_i) \\times corr(R_i,R_p) \\times \\frac{E[R_p] - R_f}{Sd(R_p)}$$\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nWhich is: \n\n$$E[R_i] - R_f > \\frac{Sd(R_i) \\times corr(R_i,R_p)}{Sd(R_p)}  \\times (E[R_p] - R_f)$$\n\n\nUsing a Beta notation:\n\n\n$$E[R_i] - R_f > \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\nThen:\n\n$$E[R_i]  >  R_f + \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nThat is, increasing the amount invested in i will increase the Sharpe ratio of portfolio P if its expected return $E[R_i]$ exceeds its required return given portfolio P, defined as\n\n$$R_i =  R_f + \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nThe required return is the **expected return that is necessary to compensate for the risk investment i will contribute to the portfolio**. \n\n. . .\n\nThe required return for an investment *i* is equal to the **risk-free interest rate plus the risk premium of the current portfolio, P, scaled by *i*’s sensitivity to P, which is $\\beta_i^P$**. \n\nIf *i*’s expected return exceeds this required return, then adding more of it will improve the performance of the portfolio.\n\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\n**To emphasize** \n\nThis equation establishes the relation between an investment’s risk and its expected return.\n\nIt states that we can determine the appropriate risk premium for an investment from its beta with the efficient portfolio.\n\n$$R_i =  R_f + \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\nThis is perhaps the most important model in Finance.\n\n**Three main assumptions:**\n\n- **Investors can buy and sell all securities** at competitive market prices (**without incurring taxes or transactions costs**) and **can borrow and lend at the risk-free interest rate**. \n  \n- **Investors hold only efficient portfolios** of traded securities.\n\n- Investors have **homogeneous expectations** regarding the volatilities, correlations, and expected returns of securities. There is no information asymmetry. \n\n. . .\n\n**If investors have homogeneous expectations, they will identify the same efficient portfolio (the highest Sharpe).**\n\n**Under the CAPM assumptions, we can identify the efficient portfolio: It is equal to the market portfolio.**\n\nA Market portfolio contains all traded securities in a economy.\n\n\n\n\n\n\n\n\n\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\nIf investors identify the same market portfolio (the highest Sharpe), then we can identify the **Capital Market Line (CML)**. \n\nAll investors will have a combination of the Market Portfolio and the Rf rate.\n\n<img src=\"figs/bm_11_11.png\" width=\"90%\" />\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int ,  \"random portfolios - All Ibov (2010-2023, yearly returns)\") ) + \n        geom_abline(intercept = 0.1, slope = max(port$sharpe), color=\"red\", size=1) +\n        xlim(0, 0.4) + ylim(0.075, 0.25) +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nplt.close()\nplt.figure(figsize=(20,10))\nplt.scatter(port['Sd'], port['Return'], alpha=0.5, color=\"darkblue\", s=50)\nplt.xlabel('Standard deviation', fontsize=25)\nplt.ylabel('Expected Return', fontsize=25)\nplt.title(str(int_) + ' random portfolios - All Ibov (2010-2023, monthly returns)' , fontsize=25)\nplt.xlim(0, 0.02+max(port['Sd']))\nplt.ylim(0, 0.02+max(port['Return']))\nax.tick_params(axis='both', which='major', labelsize=14)\nplt.plot([0, 0.75], [port['rf'].iloc[0], port['sharpe'].max()], color='red')\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        theme_solarized() + \n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int ,  \"random portfolios - All Ibov (2010-2023, yearly returns)\") ) + \n        geom_abline(intercept = max(port$rf), slope = max(port$sharpe), color=\"red\", size=1)\nggplotly(p)\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n**Under the CAPM assumptions, we can identify the efficient portfolio: It is equal to the market portfolio.**\n\nThus, we can change $R_p$ to $R_m$\n\n$$E[R_i] =  R_f + \\beta_i  \\times (E[R_m] - R_f)$$\n\nThe beta of a security measures its volatility due to market risk relative to the market as a whole, and thus captures the security’s sensitivity to market risk.\n\n**This is the CAPM!**\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\nList of Betas of Brazilian Companies.\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstart <-'2018-06-01' \nend   <- Sys.Date()\nfreq_data <-  'monthly'\nibov <- yf_get(tickers = \"^BVSP\",\n                        first_date = start,\n                        last_date = end,\n                        thresh_bad_data = 0.5,\n                        freq_data = freq_data )\nasset <- yf_collection_get(\"IBOV\", \n                         first_date = start,\n                         last_date = end,\n                         thresh_bad_data = 0.5,\n                         freq_data = freq_data )\nret_ibov <- ibov  %>%tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'monthly',\n                                  col_rename = 'return')\nret_asset <- asset %>%    \n            group_by(ticker) %>%\n            tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'monthly',\n                                  col_rename = 'return')\nret <- left_join(ret_ibov, ret_asset, by = c(\"ref_date\" = \"ref_date\"))\n#To compute beta\nvar <- ret %>% group_by(ticker) %>% summarise(var = var(return.x, return.x)) # Computing the variance of the market\ncov <- ret %>% group_by(ticker) %>% summarise(cov = cov(return.x, return.y))\nbeta <- merge(cov, var, by =\"ticker\" )\nbeta$beta <- beta$cov/beta$var\n# Risk free rate\nbeta$rf  <- 0.1 \n# Equity risk premium from here: https://ceqef.fgv.br/node/594\nbeta$erp <- 0.16 \n# expected return\nbeta$ep <- beta$rf + beta$beta * beta$erp\np<-ggplot(beta, aes(x = reorder(ticker, beta ), y = beta, fill=beta) ) +\n  geom_bar(aes(fill = -beta), position = \"dodge\", stat=\"identity\")+\n  theme(legend.position=\"none\", \n        axis.text.y = element_blank() )+\n  coord_flip()+\n  labs(y = \"Beta\", x = \"Stocks\", title = \"Betas Brazilian companies, monthly data (2018-2023)\") +   theme_solarized()\nggplotly(p)\n```\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstart = '2018-06-01'\nend = '2023-01-01'\nfreq_data = '1mo'\nibov_tickers = [\"ABEV3.SA\",\"ALPA4.SA\",\"AMER3.SA\",\"B3SA3.SA\",\"BBAS3.SA\",\"BBDC3.SA\",\"BBDC4.SA\",\"BEEF3.SA\",\"BPAN4.SA\",\"BRAP4.SA\",\"BRFS3.SA\",\"BRKM5.SA\",\"BRML3.SA\",\"CCRO3.SA\",\"CIEL3.SA\",\"CMIG4.SA\",\"COGN3.SA\",\"CPFE3.SA\",\"CPLE6.SA\",\"CSAN3.SA\",\"CSNA3.SA\",\"CYRE3.SA\",\"DXCO3.SA\",\"ECOR3.SA\",\"EGIE3.SA\",\"ELET3.SA\",\"ELET6.SA\",\"EMBR3.SA\",\"ENBR3.SA\",\"ENEV3.SA\",\"ENGI11.SA\",\"EQTL3.SA\",\"EZTC3.SA\",\"FLRY3.SA\",\"GGBR4.SA\",\"GOAU4.SA\",\"GOLL4.SA\",\"HYPE3.SA\",\"ITSA4.SA\",\"ITUB4.SA\",\"JBSS3.SA\",\"JHSF3.SA\",\"LREN3.SA\",\"MGLU3.SA\",\"MRFG3.SA\",\"MRVE3.SA\",\"MULT3.SA\",\"PCAR3.SA\",\"PETR3.SA\",\"PETR4.SA\",\"PRIO3.SA\",\"QUAL3.SA\",\"RADL3.SA\",\"RENT3.SA\",\"SANB11.SA\",\"SBSP3.SA\",\"SULA11.SA\",\"SUZB3.SA\",\"TAEE11.SA\",\"TIMS3.SA\",\"TOTS3.SA\",  \"UGPA3.SA\",\"USIM5.SA\",\"VALE3.SA\",\"VIIA3.SA\",\"VIVT3.SA\",\"WEGE3.SA\",\"YDUQ3.SA\"]\n\nibov = yf.download(tickers=\"^BVSP\", start=start, end=end, interval=freq_data)\nasset = yf.download(tickers=ibov_tickers   ,start=start, end=end, interval=freq_data)\n\nret_ibov = pd.DataFrame(ibov['Adj Close'].pct_change().dropna())\nret_ibov.columns = ['return']\n\nret_asset = pd.DataFrame()\nfor col in asset.columns.get_level_values(1).unique():\n    temp_df = pd.DataFrame(asset['Adj Close'][col].pct_change().dropna())\n    temp_df.columns = ['return']\n    temp_df['ticker'] = col.split('.')[0]\n    ret_asset = pd.concat([ret_asset, temp_df], axis=0)\nret = pd.merge(ret_ibov, ret_asset, on='Date')\n# To compute beta\nvar = pd.DataFrame(ret.groupby('ticker')['return_x'].var())\nvar = var.rename(columns={\"return_x\": \"variance\"})\ncov = ret.groupby('ticker')['return_x', 'return_y'].cov().iloc[0::2, 1]\nbeta = pd.merge(var, cov, on='ticker')\nbeta.reset_index(inplace=True)\nbeta.rename(columns={\"return_y\": \"covariance\", \"return_x\": \"variance\", \"ticker\": \"Ticker\"}, inplace=True)\nbeta = beta[['Ticker', 'variance', 'covariance']]\nbeta.head()\nbeta['beta'] = beta['covariance'] / beta['variance']\n# Risk free rate\nbeta['rf'] = 0.1\n# Equity risk premium from here: https://ceqef.fgv.br/node/594\nbeta['erp'] = 0.16\n# expected return\nbeta['ep'] = beta['rf'] + beta['beta'] * beta['erp']\n\nplt.close()\nplt.figure(figsize=(20,10))\nbeta = beta.sort_values('beta', ascending=True)\nfig, ax = plt.subplots(figsize=(20,10))\nax.barh(beta['Ticker'], beta['beta'], color='#268bd2')\nax.set_title('Betas Brazilian companies, monthly data (2018-2023)', fontsize=25)\nax.set_xlabel('Beta', fontsize=20)\nax.set_ylabel('Ticker', fontsize=20)\nplt.xticks(rotation=90, fontsize=7)\nplt.tight_layout()\nax.tick_params(axis='x', labelsize=14)\nplt.show()\n\n```\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n**The Security Market Line**\n\nThe CAPM implies there is a linear relationship between a stock's Beta and its expected return.\n\nThis linear relationship has a name: **Security Market Line (SML)**\n\n\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n![](figs/bm_11_12.png){width=\"90%\"}\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\n#Security Market Line\np<-ggplot(data=beta, aes(x = beta, y = ep  )  ) + geom_point() +\nggrepel::geom_text_repel(data=beta, aes(label = ticker) , size = 2.5 ,  max.overlaps = Inf)+\n  theme(legend.position=\"none\",  axis.text.y = element_blank() )+\n  labs(y = \"Expected return\", \n       x = \"Beta\", \n       title = \"SML Brazil, monthly data (2018-2023)\" , \n       subtitle = \"Rf = 10% per year, Risk premium = 16%\" )+   theme_solarized()\np\n```\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nplt.close()\nplt.figure(figsize=(10,6))\nplt.scatter(beta['beta'], beta['ep'], c='#268bd2', alpha=0.7, s=8)\nplt.ylabel('Expected Return', fontsize=20)\nplt.xlabel('Beta', fontsize=20)\nplt.title('SML Brazil, monthly data (2018-2023)', fontsize=20)\nplt.suptitle('Rf = 10% per year, Risk premium = 16%', fontsize=15)\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n# Questions and Final comments {.smaller background=\"#34B3B9\"}\n\n## Question {.smaller background=\"#34B3B9\"}\n\nImagine that you find the SML in the economy, and you find that two assets lies below it. **Would you buy these assets?**\n\n<img src=\"figs/bre13901_0807.jpg\" width=\"100%\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Question {.smaller background=\"#34B3B9\"}\n\n**Both assets are expensive.** They are offering less return than they are expected to offer according to the CAPM.\n\nBecause they are expensive, **investors are expected to sell them. So prices are expected to drop.**\n\n\n\n\n\n\n\n\n\n## Final comments I {.smaller background=\"#61D5DA\"}\n\n**The beta of a portfolio is the weighted average beta of the assets in the portfolio.**\n\n$$\\beta_p = \\sum_i x_i \\times \\beta_i$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Final comments II {.smaller background=\"#61D5DA\"}\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nfreq.data   <- 'daily'\nstart <-'2000-01-01' \nend   <-Sys.Date() \nibov <- yf_get(tickers = \"^BVSP\",\n                        first_date = start,\n                        last_date = end,\n                        thresh_bad_data = 0.5,\n                        freq_data = freq.data )\nasset <- yf_get(tickers = \"WEGE3.SA\",\n                        first_date = start,\n                        last_date = end,\n                        thresh_bad_data = 0.5,\n                        freq_data = freq.data )\nret_ibov <- ibov  %>%tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'daily',\n                                  col_rename = 'return',\n                                  type = 'log')\nret_asset <- asset %>%tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'daily',\n                                  col_rename = 'return',\n                                  type = 'log')\nret <- left_join(ret_ibov, ret_asset, by = c(\"ref_date\" = \"ref_date\"))\nwindow <-252\nret$var <- roll_cov(ret$return.x, ret$return.x, width = window)\nret$cov <- roll_cov(ret$return.x, ret$return.y, width = window)\nret$beta <- ret$cov / ret$var\nret <- subset(ret, ret$beta != \"NA\" )\n\nbweg<- ggplot(ret, aes(x= return.x, y=return.y)) + \n  geom_point()+\n  geom_smooth(method=lm, se=FALSE)+\n  labs( y = \"Daily returns WEGE3\", x=\"Daily returns IBOV\",title = \"Beta WEGE3\")+\n  theme(plot.title = element_text(color=\"darkgreen\", size=18, face=\"bold\"),\n        panel.background = element_rect(fill = \"grey95\", colour = \"grey95\"),\n        axis.title=element_text(size=12,face=\"bold\"),\n        title=element_text(size=10,face=\"bold\", color=\"darkgreen\"),\n        axis.text.y = element_text(face = \"bold\", color = \"darkgreen\", size = 12),\n        axis.text.x = element_text(face = \"bold\", color = \"darkgreen\", size = 12))+\n  xlim(-0.2, 0.2) + ylim(-0.2, 0.2) +   theme_solarized()\n\np<-ret %>%\n    ggplot(aes(x = ref_date, y = beta)) +\n    labs( y = \"\", x=\"\",title = \"Beta WEGE3 through time\")+\n    geom_line()+   theme_solarized()  + transition_reveal(ref_date) \n#ggplotly(p)\nanimate(p, fps = 10, duration = 10)\n```\n\n\n\n## Final comments II {.smaller background=\"#61D5DA\" visibility=\"hidden\"}\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nfreq_data = '1d'\nstart = '2000-01-01'\nend = pd.Timestamp.now()\nibov = yf.download('^BVSP', start=start, end=end, interval=freq_data)\nasset = yf.download('WEGE3.SA', start=start, end=end, interval=freq_data)\nret_ibov = np.log(ibov['Adj Close']).diff()\nret_asset = np.log(asset['Adj Close']).diff()\nret = pd.concat([ret_ibov, ret_asset], axis=1).dropna()\nwindow = 252\nvar = ret.iloc[:, 0].rolling(window).cov(ret.iloc[:, 0])\ncov = ret.iloc[:, 0].rolling(window).cov(ret.iloc[:, 1])\nbeta = cov / var\nret['beta'] = beta.values\nret.dropna(inplace=True)\nplt.close()\nplt.figure(figsize=(20, 10))\nplt.plot(ret.index, ret['beta'],c='#268bd2')\nplt.title('Beta WEGE3 through time', fontsize=25)\nplt.xlabel('Time', fontsize=18)\nplt.ylabel('Beta', fontsize=18)\nax.tick_params(axis='both', which='major', labelsize=18)\nplt.show()\n```\n\n\n\n\n\n\n\n\n\n\n\n## Final comments III {.smaller background=\"#61D5DA\"}\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\n# rf = 3%\nport1 <- port\nport1$rf <- 0.03\nport1$sharpe <- (port1$Return - port1$rf) / port1$Sd\n# rf = 7.5%\nport2 <- port\nport2$rf <- 0.075\nport2$sharpe <- (port2$Return - port2$rf) / port2$Sd\n# rf = 15%\nport3 <- port\nport3$rf <- 0.15\nport3$sharpe <- (port3$Return - port3$rf) / port3$Sd\n#ggplot\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int ,  \"random portfolios - All Ibov (2010-2023, yearly returns)\") ) + \n        geom_abline(intercept = max(port$rf) , slope = max(port$sharpe) , color=\"red\",  size=1)  +\n        geom_abline(intercept = max(port1$rf), slope = max(port1$sharpe), color=\"blue\", size=1) +\n        geom_abline(intercept = max(port2$rf), slope = max(port2$sharpe), color=\"green\", size=1) +\n        geom_abline(intercept = max(port3$rf), slope = max(port3$sharpe), color=\"orange\", size=1) +\n        xlim(0, 0.4) + ylim(0, 0.25) +   theme_solarized() +\n        geom_text( aes(x=0, y= max(port$rf)-0.02 , label = \"Rf = 10%\") , color = \"red\", hjust=-0.2, vjust=0.75, size=3.5) +\n        geom_text( aes(x=0, y= max(port1$rf)-0.02, label = \"Rf = 3%\") , color = \"blue\", hjust=-0.2, vjust=0.75, size=3.5)  +\n        geom_text( aes(x=0, y= max(port2$rf)-0.02, label = \"Rf = 7.5%\") , color = \"green\", hjust=-0.2, vjust=0.75, size=3.5)+\n        geom_text( aes(x=0, y= max(port3$rf)-0.02, label = \"Rf = 15%\") , color = \"orange\", hjust=-0.2, vjust=0.75, size=3.5)\nggplotly(p)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#  Recap {.smaller visibility=\"hidden\"}\n\n##  Recap {.smaller visibility=\"hidden\"}\n\n**After this chapter, you should know:**\n\n- Compute the variance of an equally weighted portfolio \n\n- Describe the contribution of each security to the portfolio.\n\n- Explain how an individual investor will choose from the set of efficient portfolios. Explain what is an efficient portfolio.\n\n- Describe what is meanHenrique C. Martins' Zoom Meetingt by a short sale, and illustrate how short selling extends the set of possible portfolios.\n\n- Explain the effect of combining a risk-free asset with a portfolio of risky assets, and compute the expected return and volatility for that combination.\n\n- Define the Sharpe ratio, and explain how it helps identify the portfolio with the highest possible expected return for any level of volatility, and how this information can be used to identify the tangency (efficient) portfolio.\n\n- Calculate the beta of an investment with a portfolio.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##  Recap {.smaller visibility=\"hidden\"}\n\n**After this chapter, you should know:**\n\n- Use the beta of a security, expected return on a portfolio, and the risk-free rate to decide whether buying shares of that security will improve the performance of the portfolio.\n\n- Use the risk-free rate, the expected return on the efficient (tangency) portfolio, and the beta of a security with the efficient portfolio to calculate the risk premium for an investment.\n\n- Explain why the CAPM implies that the market portfolio of all risky securities is the efficient portfolio.\n\n- Compare and contrast the capital market line with the security market line.\n\n- Define beta for an individual stock and for a portfolio.\n\n\n\n\n\n\n\n\n\n\n\n# Comments? {background=\"#a2bef5\" visibility=\"hidden\"}\n\n## Comments? {background=\"#a2bef5\"}\n\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"henriquecastror/efcomments-part-3\"\n        data-repo-id=\"R_kgDOK8BQMg\"\n        data-category-id=\"DIC_kwDOK8BQMs4Cb463\"\n        data-mapping=\"pathname\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"bottom\"\n        data-theme=\"light\"\n        data-lang=\"en\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n\n\n\n\n\n\n\n## **THANK YOU!** {background=\"#b1cafa\"}\n\n::: columns\n\n::: {.column width=\"60%\"}\n\n**QUESTIONS?**\n\n![](figs/qa2.png){width=150% heigth=150%}\n:::\n::: {.column width=\"40%\"}\n**Henrique C. Martins**\n\n-   [FGV/EAESP](https://eaesp.fgv.br/en/people/henrique-castro-martins)\n-   [Personal Website](https://henriquemartins.net/)\n-   [LinkedIn](https://www.linkedin.com/in/henriquecastror/)\n-   [Lattes](http://lattes.cnpq.br/6076997472159785)\n-   [Scholar](https://scholar.google.com.br/citations?user=7gIfkRMAAAAJ&hl=pt-BR&oi=ao)  \n:::\n:::\n\n::: footer\n:::\n\n\n\n\n","srcMarkdownNoYaml":"\n\n\n```{r setup}\n#| include: false\n#| warning: false\napi_key <- \"kfqxH5NsN8Nhe_U1NADB\"\n# library(reticulate)\n# use_python(\"C:/Users/hcmrt/AppData/Local/Programs/Python/Python310/python.exe\")\nlibrary(reticulate)\n#reticulate::py_install(\"matplotlib\")\n#reticulate::py_install(\"seaborn\")\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(gganimate)\nlibrary(ggthemes)\nlibrary(PerformanceAnalytics)\nlibrary(tidyr)\nlibrary(tidyquant)\nlibrary(roll)\nlibrary(plotly)\nlibrary(yfR)\n```\n\n\n\n\n\n\n# Intro {visibility=\"hidden\"}\n\n## {background-image=\"figs/ch11.png\" background-size=\"1300px\"}\n\n\n\n\n\n\n## Chapter Outline  \n\n11.1 The Expected Return of a Portfolio\n\n11.2 The Volatility of a Two-Stock Portfolio\n\n11.3 The Volatility of a Large Portfolio\n\n11.4 Risk Versus Return: Choosing an Efficient Portfolio\n\n11.5 Risk-Free Saving and Borrowing\n\n11.6 The Efficient Portfolio and Required Returns\n\n11.7 The Capital Asset Pricing Model\n\n11.8 Determining the Risk Premium\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.1 Expected return of a portfolio  {.smaller background=\"#c9f7ba\"}\n\n## 11.1 Expected return of a portfolio  {.smaller background=\"#c9f7ba\"}\n\n**Suppose you have two stocks:**\n\n**Amazon:** $x_1$: 40%, **Return**: 10%, **Risk**: 26.6%\n\n**Southwest:** $x_2$: 60%, **Return**: 15%, **Risk**: 27.9%\n\n. . .\n\nIf your portfolio is 40% Amazon + 60% Southwest, then your return is:\n\n\n$$(0.4 \\times 10\\%) +(0.6 \\times 15\\%) = 13\\%$$\n\n**There is no secret here, the return of a portfolio is the weighted average of returns.**\n\n**The weights are selected by the investors and, obviously, if prices change, the weights change over time.**\n\n\n\n\n\n\n\n\n\n\n\n# 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**To compute the standard deviation of a portfolio, we cannot rely on the weighted average. We have to look to the covariances.** \n\n![](figs/bre13901_0712.jpg){.absolute bottom=\"1\" right=\"1\" width=\"700\"}\n\n- $\\sigma^2_1$ = variance of asset 1. \n- $\\sigma^2_2$ = variance of asset 2\n- $\\sigma_{12}$ = covariance between assets 1 and 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\nCovariance is the product of the assets' Sd and their correlation.\n\n$$\\sigma_{12} = \\sigma_1 \\times \\sigma_2 \\times \\rho_{12}$$\n\nCovariance is the expected product of the deviations of two returns from their means.\n\n$$Cov(R_i,R_j) = E[(R_i-E[R_i]) \\times (R_j-E[R_j]) ]$$\n\n\nWhen using historical data:\n\n$$Cov(R_i,R_j) = \\frac{1}{T-1} (R_i-\\tilde{R_i} ) \\times (R_j-\\tilde{R_j} )$$\n\n. . . \n\nCorrelation:\n\n$$Corr(R_i,R_j) = \\frac{Cov(R_i,R_j)}{Sd(R_i)\\times  Sd(R_j)  }$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\nTherefore, the portfolio variance is:\n\n$$var = (x_1^2 \\times \\sigma_1^2)  + (x_2^2 \\times \\sigma_2^2) + 2(x_1 \\times x_2 \\times \\sigma_1 \\times \\sigma_2 \\times \\rho_{12})$$\n\n. . . \n\nIf $\\rho_{12} = 0.26$ \n\n$$(0.4^2 \\times 26.6^2)  + (0.6^2 \\times 27.9^2) + 2(0.4 \\times 0.6 \\times 26.6 \\times 27.9 \\times 0.26) = 486.1$$\n\nThe standard deviation of the portfolio is $\\sqrt{486.1}= 22\\%$, which is lower than 26.6% and 27.9%.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Covariance and Correlation**\n\nLet's remember the basics about correlation.\n\n![](figs/bm_11_1.png)\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Covariance and Correlation**\n\nThese assets have the same historical return and volatility, **but they 'move' very differently**: \n\n- For example, when North Air performed well, Text Oil tended to do poorly, and when North Air did poorly, Text oil  tended to do well\n\n- **North Air is not positively correlated with  Text Oil.**\n\n- Consider the portfolio which consists of equal investments in West Air and Tex Oil. The average return of the portfolio is equal to the average return of the two stocks...\n\n- ...**However, the volatility of 5.1% is much less than the volatility of the two individual stocks.**\n\n**The amount of risk that is eliminated in a portfolio depends on the degree to which the stocks face common risks and their prices move together.**\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n::: {.panel-tabset}\n\n### R \n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(PerformanceAnalytics)\nlibrary(yfR)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggthemes)\nlibrary(tidyquant)\nlibrary(roll)\nlibrary(plotly)\nlibrary(ggthemes)\nstocks <-c('BBDC3.SA', 'PETR3.SA') \nstart <-'2010-01-01' \nend   <-Sys.Date()  \ndata <- yf_get(tickers = stocks, \n                         first_date = start,\n                         last_date = end)\ndata<-data[complete.cases(data),] \np<-ggplot(data, aes(ref_date , price_close, group=ticker , color=ticker))+\n        geom_line() +\n        labs(x = \"\",\n             y='Closing prices', \n             title=\"Two assets returns\", \n             subtitle = \"Begin 01/01/2010\") +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: false\n#| code-line-numbers: true\t\n#| output-location: slide\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nimport yfinance as yf\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom scipy.stats import norm\nstocks = ['BBDC3.SA', 'PETR3.SA']\nstart = '2010-01-01'\nend = pd.Timestamp.today().strftime('%Y-%m-%d')\ndata = yf.download(stocks, start=start, end=end)['Close']\ndata = data.dropna()\n# plot the data\nplt.close()\nplt.plot(data.index, data['BBDC3.SA'], label='BBDC3.SA')\nplt.plot(data.index, data['PETR3.SA'], label='PETR3.SA')\n# add title and axis labels\nplt.title('Two assets returns')\nplt.xlabel('Date')\nplt.ylabel('Closing prices')\n# add legend\nplt.legend()\n# display the plot\nplt.show()\n```\n\n\n\n::: \n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Same graph using prices in day 1 = $100.**\n\n::: {.panel-tabset}\n\n### R \n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstock1 <- subset(data, ticker == stocks[1])\nstock2 <- subset(data, ticker == stocks[2])\nstock1$price_close2 <- stock1$price_close  / stock1$price_close[1] * 100\nstock2$price_close2 <- stock2$price_close  / stock2$price_close[1] * 100\np<-ggplot(stock1, aes(ref_date , price_close2, color=ticker))+\n        geom_line() +\n        geom_line(data=stock2) +\n        labs(x = \"\",\n             y='Closing prices', \n             title=\"Two assets returns, Initial price = 100\", \n             subtitle = \"Begin 01/01/2010\") +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python \n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nplt.close()\nstock1 = data[stocks[0]]\nstock2 = data[stocks[1]]\nstock1 = (stock1 / stock1.iloc[0]) * 100\nstock2 = (stock2 / stock2.iloc[0]) * 100\nfig, ax = plt.subplots()\nax.plot(stock1.index, stock1.values, label=stocks[0])\nax.plot(stock2.index, stock2.values, label=stocks[1])\nax.set_ylabel('Price')\nax.set_title('Two assets returns, Initial price = 100')\nax.legend()\nplt.show()\n```\n\n\n::: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\nLet's compute the average return of a portfolio with 40% invested in A and 60% in B. **The portfolio return is the average return of the assets**.\n\n::: {.panel-tabset}\n\n### R \n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\n# Defining weights and calculating portfolio return (daily)\nw <- c(0.40, 0.60)\n# Creating a df with stocks and weights\nw_tbl <- tibble(ticker = stocks,w = w)\n# Including the weights in the df prices (which contains the prices)\nprices  <- left_join(data ,w_tbl, by = 'ticker')\n# calculating the product of return times the portfolio weights for all days (this is necessary to calculate average return)\nprices$w_ret <- prices$ret_closing_prices * prices$w\n# Creating a dataframe with portfolio returns \nport_ret <- prices %>%\n  group_by(ref_date) %>%\n  summarise(port_ret = sum(w_ret))\n# Creating prices from the vector of returns\nport_ret$price_close2 <- cumprod(1+port_ret$port_ret) * 100\n# Graph with all returns\nport_ret$ticker <- 'Portfolio'\np <- ggplot(stock1, aes(ref_date , price_close2, color = ticker))+\n        geom_line() +geom_line(data=stock2) +geom_line(data=port_ret) +\n        labs(x = \"\",\n             y='Closing prices', \n             title=\"Two assets and Portfolio returns, Initial price = 100\", \n             subtitle = \"Begin 01/01/2010\") +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nplt.close()\nw = [0.40, 0.60]\n# Calculate the weighted returns for each stock\nreturns = data.pct_change().dropna()\nweighted_returns = returns.mul(w, axis=1)\n# Calculate the portfolio returns by taking the sum of the weighted returns\nportfolio_returns = weighted_returns.sum(axis=1)\n# Calculate the cumulative returns for each series\nstock_returns_cum = (1 + returns).cumprod() * 100\nportfolio_returns_cum = (1 + portfolio_returns).cumprod() * 100\n# Plot the results\nfig, ax = plt.subplots(figsize=(12, 6))\nax.plot(stock_returns_cum)\nax.plot(portfolio_returns_cum, label='Portfolio')\nax.set(title='Two assets and Portfolio returns, Initial price = 100', xlabel='', ylabel='Closing prices')\nax.legend()\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n## 11.2 Volatility of a 2-stock portfolio {.smaller background=\"#f2f7ba\"}\n\n**Covariance and Correlation**\n\nIf you don't remember how to calculate manually the correlation, please take a look at the notes of your statistics lectures.\n\n![](figs/bm_11_2.png)\n \n\n\n\n\n\n\n\n\n\n\n\n\n# 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n![](figs/bre13901_0713.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nThe variance of a three-asset portfolio can be built using a previous slide...\n\n$$var = (x_1^2 \\times \\sigma_1^2)  + (x_2^2 \\times \\sigma_2^2) + 2(x_1 \\times x_2 \\times \\sigma_1 \\times \\sigma_2 \\times \\rho_{12})$$\n\n... plus the following terms.\n\n$$+ (x_3^2 \\times \\sigma_3^2) + 2(x_1 \\times x_3 \\times \\sigma_1 \\times \\sigma_3 \\times \\rho_{13}) +  2(x_2 \\times x_3 \\times \\sigma_2 \\times \\sigma_3 \\times \\rho_{23})$$\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nNote in the previous figure: **as the number N of assets increases**, the number of **terms outside the main diagonal** increases more than the main diagonal.\n\n. . .\n\nTherefore, the **variance of a well-diversified portfolio mostly contains covariances**.\n\n. . . \n\nFor a portfolio with equal weights to all assets, We can write that:\n\n\n$$Var(R_p) = \\frac{1}{N} \\times average\\;variance + (1-\\frac{1}{N}) \\times average \\; covariance$$\n\n. . .\n\nAs N grows to infinite, only the average covariance lasts.\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nSo, if you **increase the size of your portfolio, the risk decreases** (until to a certain amount). \n\n**Usually, you can diversify about half of the initial variance.** \n\n![](figs/bm_fig_11_2.jpg) \n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large portfolio {.smaller background=\"#f5d5d5\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: false\nstart <-'2015-01-01' \nend   <-'2023-08-20'\n# Finding the tickers\ndata_temp <- yf_collection_get(\"IBOV\", first_date = start,last_date = end,freq_data = \"monthly\")\ntickers<-unique(data_temp$ticker)\ndf <- data_temp %>%  select(ref_date)  %>% distinct()\n# Now collecting data\nfor (i in 1:length(tickers)) {\ndata <- yf_get(tickers[[i]],first_date = start,last_date = end,freq_data = \"monthly\")\ndata <- data[complete.cases(data),] \ndata <- data %>%  select(ref_date, ret_closing_prices)\ncolnames(data) <- c(\"ref_date\",  tickers[[i]]  )\ndf <- merge(df,data,by=\"ref_date\")\n}\ndf$ref_date <- NULL\n# Setup to randomly combine \"j\" stocks and compute the standard deviation of this combination\nrows <- 1000\nfinal <- data.frame(matrix(NA,nrow = rows, ncol = length(tickers)))\nfor (j in 1:length(tickers) ) {\nfor (i in 1:rows ) {\ndf_r <- as.data.frame(df[, sample(  ncol(df) , j )])\ncov <- cov(df_r)\n# Var mean\nvar <- as.data.frame(diag(cov))\nvar_mean <- mean(var$`diag(cov)`)\n  #Covariance mean\n  if (j == 1) {\n  covar_mean <- var_mean\n  } else {\n  covar <- cov\n  diag(covar)=NA \n  covar[upper.tri(covar)] <- NA\n  covar<-c(covar)\n  covar_mean<- mean(covar,na.rm=TRUE)\n  }\n# Port Sd.\nvar_p <- (  (1/ j  * var_mean )   + (1- (1/j ) ) * covar_mean    ) ^ 0.5\nfinal[i,j] <- var_p\n}\n}\n# Computing the average of the \"i\" portfolios with \"j\" stocks \nsd   <- as.data.frame(colMeans(final))\nsd$N  <- seq_along(sd[,1])\np<- ggplot(sd, aes(y=`colMeans(final)` , x = N)) + geom_line() +\n        labs(x = \"Number of stocks (equal weight)\",\n             y='Standard deviation (monthly)', \n             title=\"Standard deviation of equally weighted portfolios\", \n             subtitle = \"01/01/2015-today (Brazilian stocks)\") +   theme_solarized()\nggplotly(p)\n```\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstart = '2015-01-01'\nend = pd.Timestamp.now()\nstocks = [\"ABEV3.SA\",\"ALPA4.SA\",\"AMER3.SA\",\"B3SA3.SA\",\"BBAS3.SA\",\"BBDC3.SA\",\"BBDC4.SA\",\"BEEF3.SA\",\"BPAN4.SA\",\"BRAP4.SA\",\"BRFS3.SA\",\"BRKM5.SA\",\"BRML3.SA\",\"CCRO3.SA\",\"CIEL3.SA\",\"CMIG4.SA\",\"COGN3.SA\",\"CPFE3.SA\",\"CPLE6.SA\",\"CSAN3.SA\",\"CSNA3.SA\",\"CYRE3.SA\",\"DXCO3.SA\",\"ECOR3.SA\",\"EGIE3.SA\",\"ELET3.SA\",\"ELET6.SA\",\"EMBR3.SA\",\"ENBR3.SA\",\"ENEV3.SA\",\"ENGI11.SA\",\"EQTL3.SA\",\"EZTC3.SA\",\"FLRY3.SA\",\"GGBR4.SA\",\"GOAU4.SA\",\"GOLL4.SA\",\"HYPE3.SA\",\"ITSA4.SA\",\"ITUB4.SA\",\"JBSS3.SA\",\"JHSF3.SA\",\"LREN3.SA\",\"MGLU3.SA\",\"MRFG3.SA\",\"MRVE3.SA\",\"MULT3.SA\",\"PCAR3.SA\",\"PETR3.SA\",\"PETR4.SA\",\"PRIO3.SA\",\"QUAL3.SA\",\"RADL3.SA\",\"RENT3.SA\",\"SANB11.SA\",\"SBSP3.SA\",\"SULA11.SA\",\"SUZB3.SA\",\"TAEE11.SA\",\"TIMS3.SA\",\"TOTS3.SA\",\"UGPA3.SA\",\"USIM5.SA\",\"VALE3.SA\",\"VIIA3.SA\",\"VIVT3.SA\",\"WEGE3.SA\",\"YDUQ3.SA\"]\ndata_temp = yf.download(stocks,start=start,end=end,interval='1mo', group_by='ticker')\ndf = data_temp.loc[:, (slice(None), 'Adj Close')].droplevel(level=1, axis=1)\ndf = df.pct_change()\nrows = 1000\nfinal = pd.DataFrame(np.empty((rows, len(data_temp))) * np.nan)\nfor j in range(len(stocks)):\n    for i in range(rows):\n        df_r = df.iloc[:, np.random.choice(df.shape[1], j+1, replace=False)]\n        cov = df_r.cov()\n        var = pd.DataFrame(np.diag(cov))\n        var_mean = var.mean().item()\n        if j == 0:\n            covar_mean = var_mean\n        else:\n            covar = cov.copy()\n            np.fill_diagonal(covar.values, np.nan)\n            covar = covar.where(np.triu(np.ones(covar.shape)).astype(np.bool_))\n            covar_mean = covar.stack().mean()\n        var_p = ((1/(j+1) * var_mean) + (1 - 1/(j+1)) * covar_mean) ** 0.5\n        final.iloc[i, j] = var_p\n# Computing the average of the \"i\" portfolios with \"j\" stocks \nsd = final.mean(axis=0).reset_index()\nsd = sd.rename(columns={'index': 'N', 0: 'colMeans(final)'})\nsd['N'] = sd['N'] + 1\n\nplt.close()\nplt.plot(sd['N'], sd['colMeans(final)'])\nplt.xlabel('Number of stocks (equal weight)')\nplt.ylabel('Standard deviation (monthly)')\nplt.title('Standard deviation of equally weighted portfolios')\nplt.suptitle('01/01/2015-today (Brazilian stocks)')\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\nYou can also write that\n\n$$Var(R_p) = \\sum_i x_i \\times Cov(R_i,R_p)$$\n\nThis equation indicates that the variance of a portfolio is equal to the weighted average covariance of each stock **with the portfolio**.\n\n**This expression reveals that the risk of a portfolio depends on how each stock’s return moves in relation to it.**\n\nAdditionally, notice that stocks can have different weights in this equation (the previous example assumed equal weights).\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**Final equation**\n\nThe equation in the previous slide can also be written as (remember that $Cov = sd \\times sd \\times corr$):\n\n$$Var(R_p) = \\sum_i x_i \\times Sd(R_i) \\times Sd(R_p) \\times Corr(R_i,R_p)$$\n\nIf we divide both sides of this equation by $Sd(R_p)$, we find:\n\n$$Sd(R_p) = \\sum_i x_i \\times Sd(R_i)  \\times Corr(R_i,R_p)$$\n\nThis equation shows the amount of risk that each security brings to portfolio.\n\nEach asset *i* contributes to the portfolio's volatility according to its Sd scaled by its correlation with the portfolio.\n\n**Keep this equation in mind, we will use it in the future.**\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**More about correlation**. \n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.50\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.05)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\ndf <- df %>%  mutate(Condition = case_when(w1<0 ~ \"W1<0\" , w1>1 ~ \"W1>1\"  , 0<w1 | w1<1 ~ \"0<w1<1\" ))\nd1 <- df[df$w1 == 1, ]\nd2 <- df[df$w2 == 1, ]\np<-ggplot(df, aes(sdp, retp, color= Condition) ) + \n        geom_point(size=3)  +\n        labs(x = \"Standard deviation\",y='Expected return') +\n        xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n      geom_text(data = d1, aes(x=sd1+0.01, y=ret1-0.01, label = \"Asset 1\") , color = \"black\", hjust=0.2, vjust=0.75, size=4) +\n      geom_text(data = d2, aes(x=sd2-0.02, y=ret2-0.01, label = \"Asset 2\") , color = \"black\", hjust=0.1, vjust=0.75, size=4) +\n      ggtitle(paste(\"Correlation = \" , corr12)) +theme_solarized()\nggplotly(p)\n```\n\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n#data\ncorr12 = -0.50\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\n#weight \nw1 = np.arange(-0.4, 1.4, 0.05)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [\"portfolio\" + str(i+1) for i in range(len(w1))]\ndf = pd.DataFrame({'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp})\ndf['Condition'] = np.select(  [df['w1']<0, df['w1']>1, (df['w1']>0) & (df['w1']<1)], ['green', 'blue', 'red'])\n#Conditions to graph\nd1 = df[df['w1'] == 1]\nd2 = df[df['w2'] == 1]\n#Graph\nplt.close()\nfig, ax = plt.subplots()\nax.scatter(df['sdp'], df['retp'], c=df['Condition'], cmap='viridis')\nax.set(xlabel='Standard deviation', ylabel='Expected return', xlim=(0, max(sdp)), ylim=(0, max(retp)))\nax.set_title(\"Correlation = {}\".format(corr12))\nax.text(sd1+0.005,ret1-0.005, 'Asset 1', color='black', ha='left', va='center', fontsize=10)\nax.text(sd2+0.005,ret2+0.005, 'Asset 2', color='black', ha='left', va='center', fontsize=10)\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(ggpubr)\nlibrary(dplyr)\n# Create a vector of correlation values to loop through\ncorrs <- c(0.9, 0.5, 0, -0.5, -0.9, - 1)\n# Initialize an empty list to store plots\nplot_list <- list()\n# Loop through each correlation value and create a plot\nfor (corr12 in corrs) {\n  ret1 <- 0.175\n  sd1 <- 0.258\n  var1 <- sd1^2\n  ret2 <- 0.055\n  sd2 <- 0.115\n  var2 <- sd2^2\n  covar12 <- corr12*sd1*sd2\n  w1 <- seq(from=-0.4, to=1.4, by=0.05)\n  w2 <- 1 - w1\n  retp <- w1*ret1 + w2*ret2\n  varp <- w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\n  sdp <- sqrt(varp)\n  port.names <- paste(\"portfolio\", 1:length(w1), sep=\" \")\n  df <- data.frame(port.names, w1, w2, retp, sdp)\n  df <- df %>%  mutate(Condition = case_when(w1<0 ~ \"W1<0\" , w1>1 ~ \"W1>1\"  , 0<w1 | w1<1 ~ \"0<w1<1\" ))\n  d1 <- df[df$w1 == 1, ]\n  d2 <- df[df$w2 == 1, ]\n  plot <- ggplot(df, aes(sdp, retp, color= Condition) ) + \n    geom_point(size=2) +\n    labs(x = \"\",y=\"\")+\n    xlim(0, max(sdp)) + ylim(0, max(retp)) +\n    theme(legend.position = \"none\") +\n    theme()+\n    ggtitle(paste(\"Correlation = \" , corr12))\n  plot_list[[length(plot_list) + 1]] <- plot\n}\n# Arrange the plots in a 3x2 grid using ggarrange\nggarrange(plot_list[[1]], plot_list[[2]], plot_list[[3]],\n          plot_list[[4]], plot_list[[5]], plot_list[[6]],\n          nrow = 3, ncol = 2)\n```\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n#data\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\n#weight \nw1 = np.arange(-0.4, 1.4, 0.05)\nw2 = 1 - w1\n# create a list of correlation values\ncorr_values = [0.9, 0.5, 0, -0.5, -0.9, -1]\nplt.close()\n# create a 2x3 grid of subplots\nfig, axs = plt.subplots(2, 3, figsize=(20, 10))\n# loop through each correlation value and plot the corresponding scatter plot\nfor i, corr12 in enumerate(corr_values):\n    covar12 = corr12*sd1*sd2\n    retp = w1*ret1 + w2*ret2\n    varp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\n    sdp = np.sqrt(varp)\n    port_names = [\"portfolio\" + str(i+1) for i in range(len(w1))]\n    df = pd.DataFrame({'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp})\n    df['Condition'] = np.select([df['w1']<0, df['w1']>1, (df['w1']>0) & (df['w1']<1)], ['green', 'blue', 'red'])\n    d1 = df[df['w1'] == 1]\n    d2 = df[df['w2'] == 1]\n    ax = axs[i//3, i%3]  \n    ax.scatter(df['sdp'], df['retp'], c=df['Condition'], cmap='viridis')\n#    ax.set(xlabel='Standard deviation', ylabel='Expected return', xlim=(0, max(sdp)), ylim=(0, max(retp)))\n    ax.set_title(\"Correlation = {}\".format(corr12), fontsize=16)\n    ax.tick_params(labelsize=14)\n#    ax.set_xlabel('Standard deviation', fontsize=16)\n#    ax.set_ylabel('Expected return', fontsize=20)\nplt.tight_layout()  # adjust spacing between subplots\nplt.show()\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**More about correlation**\n\nIn these graphs, I am assuming that you can invest a negative amount in a stock. This is called a **short position**. When you buy, you have a **long position**.\n\n**Short sales** are usually allowed if you provide enough security and collateral to the market. \n\nThe idea is that you think that a stock's price will go down so you sell it. Later, you buy it back (but if the price goes up, you lose part of your investment).\n\n**Notice that if you can short sale, you amplify the pairs return-risk available**.\n\n\n\n\n\n\n\n\n\n\n## 11.3 Volatility of a large  portfolio {.smaller background=\"#f5d5d5\"}\n\n**Correlations usually positive**.\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstocks <-c(\"ITUB3.SA\", \"WEGE3.SA\", \"PETR3.SA\", \"VALE3.SA\", \"ITSA3.SA\" , \"BBAS3.SA\", \"ABEV3.SA\", \"GGBR4.SA\", \"LREN3.SA\", \"B3SA3.SA\", \"UGPA3.SA\", \"CSMG3.SA\", \"HYPE3.SA\") \nstart <-'2010-01-01' \nend   <- Sys.Date() \ndf <- yf_get(tickers = stocks[[1]], \n                         first_date = start,\n                         last_date = end,\n                         freq_data = \"monthly\")\ndf <- df %>%  select(ref_date)\n\nfor (i in 1:length(stocks)) {\ndata <- yf_get(tickers = stocks[[i]], \n                         first_date = start,\n                         last_date = end,\n                         freq_data = \"monthly\")\ndata<-data[complete.cases(data),] \ndata<- data %>%  select(ref_date, ret_adjusted_prices)\ncolnames(data) <- c(\"ref_date\",  stocks[[i]]  )\ndf <- merge(df,data,by=\"ref_date\")\n}\ndf$ref_date <-NULL\ncor<- cor(df, method = c(\"pearson\"))\nlibrary(corrplot)\ncorrplot(cor,method = 'number' ,  tl.col = \"black\",   tl.cex = 0.9,  col = COL1('Reds') , number.cex = 0.8)\n```\n\n\n\n\n\n\n\n\n\n### Python\n\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstocks = [\"ITUB3.SA\", \"WEGE3.SA\", \"PETR3.SA\", \"VALE3.SA\", \"ITSA3.SA\", \"BBAS3.SA\", \"ABEV3.SA\", \"GGBR4.SA\", \"LREN3.SA\", \"B3SA3.SA\", \"UGPA3.SA\", \"CSMG3.SA\", \"HYPE3.SA\"]\nstart = '2010-01-01'\nend = pd.Timestamp.now()\ndf = yf.download(stocks[0], start=start, end=end, interval=\"1mo\")[[\"Adj Close\"]]\ndf.columns = [stocks[0]]\nfor stock in stocks[1:]:\n    data = yf.download(stock, start=start, end=end, interval=\"1mo\")[[\"Adj Close\"]]\n    data.columns = [stock]\n    df = df.merge(data, how=\"inner\", on=\"Date\")\ndf = df.ffill()  # forward-fill missing values\ncor = df.corr(method=\"pearson\")\nsns.heatmap(cor, annot=True, fmt=\".2f\", cmap=\"Reds\", annot_kws={\"fontsize\":20})\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\nNow, you can understand what an **efficient portfolio** is.\n\n- It is the portfolio that brings the **higher return for any given level of risk**\n- or a portfolio that brings the **lower risk for any given return**.\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\nw1_min = round((var2 - covar12)/(var1 + var2 - 2*covar12), digits = 1)\nw2_min = 1 - w1_min\nd_min <- df[w2_min <= df$w2, ]\nd_min <- data.frame(d_min[ nrow(d_min) ,])\ndf <- df %>%  mutate(Efficient = case_when(w2<=w2_min ~ \"Efficient\" , w2>w2_min ~ \"Not Efficient\" ))\np<-ggplot(df, aes(sdp, retp, color = Efficient) ) + \n        geom_point(size=1)  +\n        labs(x = \"Standard deviation\",y='Expected return') +\n        xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n      geom_text(data = d_min, aes(x=sd1+0.01, y=ret1-0.01, label = \"Asset 1\") , hjust = -0.1, color = \"black\", size=4)  +   \n      geom_text(data = d_min, aes(x=sd2-0.02, y=ret2-0.01, label = \"Asset 2\") , hjust = -0.1, color = \"black\", size=4)  +   \n      geom_text(data = d_min, aes(x=sdp+0.06, y=retp, label = \"Minimum variance portfolio\") , hjust = -0.1, color = \"black\", size=4)  +   \n      theme_solarized()\nggplotly(p)\n```\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n# Set up variables\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\nw1 = np.arange(-0.4, 1.41, 0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [f\"portfolio {i+1}\" for i in range(len(w1))]\ndata = {'port_names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp}\ndf = pd.DataFrame(data)\nw1_min = round((var2 - covar12)/(var1 + var2 - 2*covar12), 1)\nw2_min = 1 - w1_min\nd_min = df.loc[df['w2'] >= w2_min, :]\nd_min = pd.DataFrame(d_min.iloc[-1, :]).T\ndf['Efficient'] = np.where(df['w2'] <= w2_min, 'Efficient', 'Not Efficient')\n# Plotting\nfig, ax = plt.subplots(figsize=(20, 10))\ncolors = {'Efficient': '#dc322f', 'Not Efficient': '#2aa198'}\nfor label, color in colors.items():\n    mask = df['Efficient'] == label\n    ax.scatter(df.loc[mask, 'sdp'], df.loc[mask, 'retp'], c=color, label=label, alpha=0.7, s=50)\nax.set_xlabel('Standard deviation', fontsize=25)\nax.set_ylabel('Expected return', fontsize=25)\nax.set_xlim(0, max(sdp))\nax.set_ylim(0, max(retp))\nax.text(sd1+0.01,ret1, 'Asset 1', color='black', ha='left', va='center', fontsize=20)\nax.text(sd2+0.01,ret2, 'Asset 2', color='black', ha='left', va='center', fontsize=20)\nax.text(sd2-0.01,ret2+0.02, 'Minimum Variance Portfolio', color='black', ha='left', va='center', fontsize=20)\nax.legend(fontsize=20)\nax.tick_params(axis='both', which='major', labelsize=20, color='#839496', length=8, width=1.5)\nplt.grid(color='#657b83', linestyle='--', linewidth=0.5, alpha=0.5)\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n**Example with real data**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(yfR)\nlibrary(kableExtra)\nstart <-'2010-01-01' \nend   <-Sys.Date()  \nfreq_data <-  'monthly'\nticker1 <- 'BBDC3.SA'\nticker2 <- 'PETR3.SA'\nasset1 <- yf_get(tickers = ticker1, first_date = start,last_date = end,freq_data = freq_data)\nasset2 <- yf_get(tickers = ticker2, first_date = start,last_date = end,freq_data = freq_data)\nasset1<-asset1[complete.cases(asset1),] \nasset2<-asset2[complete.cases(asset2),] \ner_1 <- mean(asset1$ret_adjusted_prices) \ner_2 <- mean(asset2$ret_adjusted_prices)\nsd_1 <- sd(asset1$ret_adjusted_prices) \nsd_2 <- sd(asset2$ret_adjusted_prices) \ntable <- data.frame(\"Ticker\" = c(ticker1 , ticker2), \n                 \"ER\" = c(er_1* 100 , er_2* 100), \n                 \"SD\" = c(sd_1* 100, sd_2* 100)) \nkable(table,col.names = c(\"Ticker\", \"Expected Return\", \"Standard Deviation\"), \n            align = c(\"l\", \"r\", \"r\"), \n            format.args = list(big.mark = \",\", decimal.mark = \".\", scientific = FALSE), \n            caption = \"Summary statistics (monthly returns since 2010)\") %>%\n  kable_styling(bootstrap_options = \"striped\")\n```\n\n\n\n\n\n### Python\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\np<-ggplot(table, aes(x = SD, y = ER, color = Ticker)) +\n      geom_point(size = 4) +\n      theme_bw() + \n      ggtitle(\"Risk-Return Tradeoff, 2010 to 2023.\") +\n      xlab(\"Standard deviation\") + ylab(\"Expected Return\") +\n      scale_y_continuous( limits = c(min(table$ER)*0.95, max(table$ER)*1.05)) +\n      scale_x_continuous( limits = c(min(table$SD)*0.95, max(table$SD)*1.05))+   theme_solarized()\nggplotly(p)\n```\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nlibrary(data.table)\ncov_12 <- cov(asset1$ret_adjusted_prices, asset2$ret_adjusted_prices)\ncorr_12 <- cor(asset1$ret_adjusted_prices, asset2$ret_adjusted_prices)\nweights <- seq(from = 0, to = 1, length.out = 1000)\ntwo_assets <- data.table(w1 = weights ,w2 = 1 - weights)\n# calculate the expected returns and standard deviations for the 1000 possible portfolios\ntwo_assets[, ':=' (er_p = w1 * er_1 + w2 * er_2,\n                   sd_p = sqrt(w1^2 * sd_1^2 +w2^2 * sd_2^2 +2 * w1 * w2 * cov_12))]\np<-ggplot() +\ngeom_point(data = two_assets, aes(x = sd_p, y = er_p, color = w1)) +\ngeom_point(data = data.table(sd = c(sd_1, sd_2), mean = c(er_1, er_2)),\naes(x = sd, y = mean), color = \"red\", size = 3, shape = 18) +\ntheme_bw() + ggtitle(\"Possible Portfolios with Two Risky Assets\") +\nxlab(\"Standard deviation\") + ylab(\"Expected Return\") +\n      scale_y_continuous( limits = c(min(two_assets$er_p)*0.99, max(two_assets$er_p)*1.01)) +\n      scale_x_continuous( limits = c(min(two_assets$sd_p)*0.9, max(two_assets$sd_p)*1.1)) +   theme_solarized() +scale_color_continuous(name = \"W. Asset 1\")\nggplotly(p)\n```\n\n\n\n\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstart = '2010-01-01'\nend = pd.to_datetime('today')\nfreq_data = '1mo'\nticker1 = 'BBDC3.SA'\nticker2 = 'PETR3.SA'\nasset1 = yf.download(ticker1, start=start, end=end, interval=freq_data)['Adj Close']\nasset2 = yf.download(ticker2, start=start, end=end, interval=freq_data)['Adj Close']\nasset1 = asset1.dropna()\nasset2 = asset2.dropna()\ner_1 = np.mean(asset1.pct_change().dropna()) * 12\ner_2 = np.mean(asset2.pct_change().dropna()) * 12\nsd_1 = np.std(asset1.pct_change().dropna()) * np.sqrt(12)\nsd_2 = np.std(asset2.pct_change().dropna()) * np.sqrt(12)\ncov_12 = np.cov(asset1.pct_change().dropna(), asset2.pct_change().dropna())[0, 1]\ncorr_12 = np.corrcoef(asset1.pct_change().dropna(), asset2.pct_change().dropna())[0, 1]\nweights = np.linspace(0, 1, 1000)\ntwo_assets = pd.DataFrame({'w1': weights, 'w2': 1 - weights})\ntwo_assets['er_p'] = two_assets['w1'] * er_1 + two_assets['w2'] * er_2\ntwo_assets['sd_p'] = np.sqrt(two_assets['w1']**2 * sd_1**2 + two_assets['w2']**2 * sd_2**2 + 2 * two_assets['w1'] * two_assets['w2'] * cov_12)\nplt.close()\nplt.figure(figsize=(20,10))\nplt.scatter(two_assets['sd_p'], two_assets['er_p'], c=two_assets['w1'])\nplt.scatter(sd_1, er_1, color='red', marker='s', s=100)\nplt.scatter(sd_2, er_2, color='red', marker='s', s=100)\nplt.title('Possible Portfolios with Two Risky Assets',fontsize=25)\nplt.xlabel('Standard deviation',fontsize=22)\nplt.ylabel('Expected Return',fontsize=22)\nplt.xlim(min(two_assets['sd_p']) * 0.9, max(two_assets['sd_p']) * 1.1)\nplt.ylim(min(two_assets['er_p']) * 0.99, max(two_assets['er_p']) * 1.01)\nplt.colorbar(label=r'$Weight\\;Asset\\;1$')\nax.tick_params(axis='both', which='major', labelsize=18)\nplt.show()\n```\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\nAs a financial manager, one crucial job you have is to find the **efficient portfolios** and the **minimum variance portfolio**.\n\n![](figs/bm_11_4.png)\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n**If you add stocks you improve the frontier**\n\nWhen you combine several assets, you will have what is called **efficient frontier**.\n\n![](figs/bm_11_8.png)\n\n\n\n\n\n\n\n## 11.4 Choosing an Efficient Portfolio {.smaller  background=\"#ced8f5\" }\n\n**The frontier is not so clear here**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstart <-'2010-01-01' \nend   <- '2023-01-01'\nfreq_data <- \"yearly\"\ndf <- yf_collection_get(\"IBOV\", \n                         first_date = start,\n                         last_date = end,\n                         freq_data = freq_data)\nstocks <- unique(df$ticker)\ndf <- df %>%  select(ref_date)\n\nfor (i in 1:length(stocks)) {\ndata <- yf_get(tickers = stocks[[i]], \n                         first_date = start,\n                         last_date = end,\n                         freq_data = freq_data)\ndata<-data[complete.cases(data),] \ndata<- data %>%  select(ref_date, ret_closing_prices)\ncolnames(data) <- c(\"ref_date\",  stocks[[i]]  )\ndf <- merge(df,data,by=\"ref_date\")\n}\n\ndup <- duplicated(df)\ndf <- unique(df[!dup,])\n\ndf$ref_date <-NULL\nret <- as.vector(colMeans(df))\ncov <- cov(df)\n\n# Random numbers to create the frontier\nset.seed(100)\nint <- 10000\nw<- data.frame((replicate(length(stocks),sample(int,rep=TRUE)) / int ))\nw$sum <-  rowSums(w)\ncolnames(w) <- c(stocks, 'Sum')\nfor (i in 1:int) {\nw[i, 1:length(stocks)] <- w[i, 1:length(stocks)] / w[i, ncol(w)]\n}\n\nw$Sum <- NULL\n# creating final dataframe\nport <- data.frame(matrix(NA,nrow = int,ncol = 2))\ncolnames(port) <- c(\"Return\", \"Sd\")\nfor (i in 1:int) {\nport[i,1] <- sum(  w[i, ] * ret)\nport[i,2] <- sqrt( as.matrix(w[i, ]) %*% as.matrix(cov) %*% as.matrix(t(w[i, ]) )) \n}\n#ggplot\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        theme_solarized() + \n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int , \"random portfolios - All Ibov (2010-2023, yearly returns)\") )\nggplotly(p)\n```\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: false\n#| results: false\n#| output: false\n#| code-fold: true\n#| code-line-numbers: false\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nstart = '2010-01-01'\nend = '2023-01-01'\nfreq_data = '1mo'\n#stocks = r.yf_collection_get(\"IBOV\", first_date = start,last_date = end,freq_data = \"yearly\")\nstocks = [\"ABEV3.SA\",\"ALPA4.SA\",\"AMER3.SA\",\"B3SA3.SA\",\"BBAS3.SA\",\"BBDC3.SA\",\"BBDC4.SA\",\"BEEF3.SA\",\"BPAN4.SA\",\"BRAP4.SA\",\"BRFS3.SA\",\"BRKM5.SA\",\"BRML3.SA\",\"CCRO3.SA\",\"CIEL3.SA\",\"CMIG4.SA\",\"COGN3.SA\",\"CPFE3.SA\",\"CPLE6.SA\",\"CSAN3.SA\",\"CSNA3.SA\",\"CYRE3.SA\",\"DXCO3.SA\",\"ECOR3.SA\",\"EGIE3.SA\",\"ELET3.SA\",\"ELET6.SA\",\"EMBR3.SA\",\"ENBR3.SA\",\"ENEV3.SA\",\"ENGI11.SA\",\"EQTL3.SA\",\"EZTC3.SA\",\"FLRY3.SA\",\"GGBR4.SA\",\"GOAU4.SA\",\"GOLL4.SA\",\"HYPE3.SA\",\"ITSA4.SA\",\"ITUB4.SA\",\"JBSS3.SA\",\"JHSF3.SA\",\"LREN3.SA\",\"MGLU3.SA\",\"MRFG3.SA\",\"MRVE3.SA\",\"MULT3.SA\",\"PCAR3.SA\",\"PETR3.SA\",\"PETR4.SA\",\"PRIO3.SA\",\"QUAL3.SA\",\"RADL3.SA\",\"RENT3.SA\",\"SANB11.SA\",\"SBSP3.SA\",\"SULA11.SA\",\"SUZB3.SA\",\"TAEE11.SA\",\"TIMS3.SA\",\"TOTS3.SA\",\"UGPA3.SA\",\"USIM5.SA\",\"VALE3.SA\",\"VIIA3.SA\",\"VIVT3.SA\",\"WEGE3.SA\",\"YDUQ3.SA\"]\ndf = yf.download(stocks, start=start, end=end, interval=freq_data)[['Adj Close']]\ndf = df.reset_index()[['Date']]\nfor stock in stocks:\n    data = yf.download(stock, start=start, end=end, interval=freq_data)\n    data = data.dropna() \n    data = data[['Adj Close']]\n    data.columns = [stock]\n    df = pd.merge(df, data, on='Date', how='outer')\n\ndf = df.drop(df.columns[[0,1]], axis=1)\n#Return and covariance calculation\nret = df.pct_change().mean(axis=0)\nret_m = df.pct_change()\ncov = ret_m.cov()\n\n# Random numbers to create the frontier\nnp.random.seed(100)\nint_ = 10000\nw = np.random.randint(0, int_+1, size=(int_, len(stocks))) / int_\nw = w / np.sum(w, axis=1, keepdims=True)\n# creating final dataframe\nport = pd.DataFrame(np.zeros((int_, 2)), columns=[\"Return\", \"Sd\"])\ncov_array = cov.values  # Convert covariance matrix to NumPy array\nfor i in range(int_):\n    port.iloc[i, 0] = np.sum(w[i, :len(stocks)] * ret)\n    port.iloc[i, 1] = np.sqrt(np.matmul(np.matmul(w[i, :], cov_array), w[i, :].T))\n    \n#plot\nplt.close()\nplt.figure(figsize=(20,10))\nplt.scatter(port['Sd'], port['Return'], alpha=0.5, color=\"darkblue\", s=50)\nplt.xlabel('Standard deviation', fontsize=25)\nplt.ylabel('Expected Return', fontsize=25)\nax.tick_params(axis='both', which='major', labelsize=18)\nplt.title(str(int_) + ' random portfolios - All Ibov (2010-2023, monthly returns)' , fontsize=25)\nplt.show()\n```\n\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n# 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nThus far, we have considered the risk and return possibilities that result from combining risky investments into portfolios. \n\nBy including all risky investments in the construction of the efficient frontier, we achieve **the maximum diversification possible with risky assets**.\n\nNow, let's see what happens when you **combine a portfolio of risky assets with the risk free asset.**\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nThe return is:\n\n$$E[R_{px}] =  x \\times E[R_p] + (1-x) \\times R_f $$\n\n$x$ is the weight invested in the portfolio:\n\n. . .\n\nWhich leads to:\n\n$$E[R_{px}] =  x \\times E[R_p] + R_f - x \\times R_f $$\n\n$$E[R_{px}] =  R_f + x \\times ( E[R_p] - R_f ) $$\n\nThe second equation shows that: **The expected return is equal to the risk-free rate plus a fraction of the portfolio’s risk premium, $E[R_p] - R_f$, based on the fraction x that we invest in it.**\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nRemember that the risk free rate is assumed to have no risk, thus no variance. The standard deviation is:\n\n- $$Sd(R_{px}) = \\sqrt{(1-x)^2 \\times Var(R_f) + x^2 \\times Var(R_p)  + 2 \\times(1-x) \\times x \\times Cov(R_f, R_p)}$$\n\nWhich leads to\n\n$$Sd(R_{px}) = \\sqrt{x^2 \\times Var(R_p)}$$\n\n$$Sd(R_{px}) = x \\times Sd(R_p)$$\n\nThat is, the volatility is only a fraction of the volatility of the portfolio, based on the amount we invest in it.\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n**Combine an asset with the Rf rate**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\nrf = 0.03\n#asset 1\nw1    = seq(from=0, to=1.4, by=0.01)\nwrf1   = 1 - w1\nretp1 = wrf1 * rf + w1 * ret1\nsdp1  = w1*sd1\n#asset2 \nw2    = seq(from=0, to=1.4, by=0.02)\nwrf2   = 1 - w2\nretp2 = wrf2 * rf + w2 * ret2\nsdp2  = w2*sd2\n#dfs\ndf1 <- data.frame(w1, retp1, sdp1)\ndf2 <- data.frame(w2, retp2, sdp2)\nd1 <- df1[df1$w1 == 1, ]\nd2 <- df2[df2$w2 == 1, ]\n#ggplot\np<-ggplot() +  \n  geom_point(data=df1, aes(x=sdp1, y=retp1, color=ifelse(w1>1,\"blue\",\"lightblue\")), size=1, show.legend = FALSE) +\n  geom_point(data=df2, aes(x=sdp2, y=retp2, color=ifelse(w2>1,\"red\",\"pink\")), size=1, show.legend = FALSE) +\n  labs(x = \"Standard deviation\",y='Expected return', title = \"Risk and Return of two assets combined with the Risk-Free Rate\" ) +\n  xlim(0, max(sdp1)) + ylim(0, max(retp1) ) +\n  geom_text(data = d1, aes(x=sdp1, y=retp1-0.01, label = \"Asset 1\") , color = \"black\", hjust=0.2, vjust=0.75, size=4) +\n  geom_text(data = d2, aes(x=sdp2, y=retp2-0.01, label = \"Asset 2\") , color = \"black\", hjust=0.1, vjust=0.75, size=4) +\n  geom_text(data = as.data.frame(rf), aes(x=0.02, y=rf-0.01, label = \"Risk-free\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +   \n  scale_color_identity() + \n  theme_solarized()\nggplotly(p)\n```\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n\nplt.close()\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\nrf = 0.03\n#asset 1\nw1 = np.arange(0, 1.4, 0.01)\nwrf1 = 1 - w1\nretp1 = wrf1 * rf + w1 * ret1\nsdp1 = w1 * sd1\n#asset2 \nw2 = np.arange(0, 1.4, 0.02)\nwrf2 = 1 - w2\nretp2 = wrf2 * rf + w2 * ret2\nsdp2 = w2 * sd2\n#dfs\ndf1 = np.column_stack((w1, retp1, sdp1))\ndf2 = np.column_stack((w2, retp2, sdp2))\nd1 = df1[df1[:, 0] == 1, :]\nd2 = df2[df2[:, 0] == 1, :]\n#plot\nplt.figure(figsize=(10, 6))\nplt.scatter(sdp1, retp1, c=np.where(w1>1, 'blue', 'lightblue'), s=15, edgecolors='none')\nplt.scatter(sdp2, retp2, c=np.where(w2>1, 'red', 'pink'), s=15, edgecolors='none')\nplt.plot(d1[0, 2], d1[0, 1], 'ko', markersize=5)\nplt.plot(d2[0, 2], d2[0, 1], 'ko', markersize=5)\nplt.annotate('Asset 1', xy=(d1[0, 2], d1[0, 1]), xytext=(d1[0, 2], d1[0, 1]-0.01), color='black', fontsize=10)\nplt.annotate('Asset 2', xy=(d2[0, 2], d2[0, 1]), xytext=(d2[0, 2], d2[0, 1]-0.01), color='black', fontsize=10)\nplt.annotate('Risk-free',  xy=(0.015, rf-0.01), xytext=(0.01, rf-0.01), color='black', fontsize=10)\nplt.xlabel('Standard deviation', fontsize=15)\nplt.ylabel('Expected return', fontsize=15)\nplt.title('Risk and Return of two assets combined with the Risk-Free Rate', fontsize=15)\nplt.xlim(0, sdp1.max())\nplt.ylim(0, retp1.max())\nplt.show()\n```\n\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nRemember that **we have several potential combinations between Assets 1 and 2**. \n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\nd1 <- df[df$w1 == 1, ]\nd2 <- df[df$w2 == 1, ]\ndf1 <- data.frame(w1, retp, sdp)\nrf = 0.03\nwrf1   = 1 - w1\nwrf2   = 1 - w2\nretp1  = wrf1 * rf + w1 * ret1\nsdp1   = w1*sd1\nretp2  = wrf2 * rf + w2 * ret2\nsdp2   = w2*sd2\n\np <- ggplot() +\n  geom_point(data=df, aes(x=sdp, y=retp, color=ifelse(w1>1,\"red\" ,ifelse(w1<0,\"grey\",\"pink\"))), size=1, show.legend = FALSE) +\n  geom_point(data=df1,aes(x=sdp1,y=retp1,color=ifelse(w1>1,'blue','lightblue')), size=1, show.legend = FALSE) +\n            geom_point()  +\n            labs(x = \"Standard deviation\",y='Expected return', title = \"Combinations of Risk and Return of two assets and the Risk-Free Rate\" ) +\n            xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n            geom_text(data = d1, aes(x=sdp+0.015, y=retp-0.01, label = \"Asset 1\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = d2, aes(x=sdp+0.035, y=retp, label = \"Asset 2\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = as.data.frame(rf), aes(x=0.02, y=rf-0.01, label = \"Risk-free\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +            theme_solarized()+scale_color_identity()\nggplotly(p)\n```\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\nw1 = np.arange(-0.4, 1.41, 0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [f\"portfolio{i+1}\" for i in range(len(w1))]\ndf = {'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp}\ndf = pd.DataFrame(df)\nd1 = df[df['w1'] == 1]\nd2 = df[df['w2'] == 1]\nrf = 0.03\nwrf1   = 1 - w1\nwrf2   = 1 - w2\nretp1  = wrf1 * rf + w1 * ret1\nsdp1   = w1*sd1\nretp2  = wrf2 * rf + w2 * ret2\nsdp2   = w2*sd2\n#plot\nplt.close()\nfig, ax = plt.subplots()\nscatter1 = ax.scatter(df['sdp'], df['retp'], s=3, c=np.where(df['w1'] > 1, 'red', np.where(df['w1'] < 0, 'grey', 'pink')))\nscatter2 = ax.scatter(sdp1, retp1, s=3, c=np.where(df['w1'] > 1, 'blue', 'lightblue'))\nplt.xlim(0, max(df['sdp']))\nplt.ylim(0, max(df['retp']))\nplt.xlabel('Standard deviation',fontsize=12)\nplt.ylabel('Expected return',fontsize=12)\nax.text(0.005, 0.025, 'Risk-free', color='black', ha='left', va='center', fontsize=10)\nax.text(sd1+0.01,ret1, 'Asset 1', color='black', ha='left', va='center', fontsize=10)\nax.text(sd2+0.01,ret2, 'Asset 2', color='black', ha='left', va='center', fontsize=10)\nplt.title('Combinations of Risk and Return of two assets and the Risk-Free Rate', fontsize=15)\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nIn this situation, we are better off investing in the **Tangent portfolio**, then \"moving\" to adjust the level of risk.\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1^2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2^2\ncovar12 = corr12*sd1*sd2\nw1 = seq(from=-0.4, to=1.4, by=0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1^2 * var1 + w2^2 * var2 + 2*w1*w2*covar12\nsdp = sqrt(varp)\nport.names = paste(\"portfolio\", 1:length(w1), sep=\" \")\ndf <- data.frame(port.names, w1, w2, retp, sdp)\nd1 <- df[df$w1 == 1, ]\nd2 <- df[df$w2 == 1, ]\ndf1 <- data.frame(w1, retp, sdp)\n# Including risk free rate\nrf = 0.03\nwrf1   = 1 - w1\nwrf2   = 1 - w2\nretp1  = wrf1 * rf + w1 * ret1\nsdp1   = w1*sd1\nretp2  = wrf2 * rf + w2 * ret2\nsdp2   = w2*sd2\ndfrf1 <- data.frame(w1, retp1, sdp1)\n# Tangent portfolio\ntop = (ret1 - rf)*var2 - (ret2 - rf)*covar12\nbot = (ret1 - rf)*var2 + (ret2 - rf)*var1 - (ret1 - rf + ret2 - rf)*covar12\nw1_t = top/bot\nw2_t = 1 - w1_t\nretp_t = w1_t*ret1 + w2_t*ret2\nvarp_t = w1_t^2 * var1 + w2_t^2 * var2 + 2*w1_t*w2_t*covar12\nsdp_t = sqrt(varp_t)\ntan = (retp_t - rf)/sdp_t\ndft <- data.frame(w1_t, retp_t, sdp_t)\n# exploding tangent line\nwt    = seq(from=0, to=2, by=0.01)\nwrft   = 1 - wt\nretpt = wrft * rf + wt * retp_t\nsdpt  = wt*sdp_t\ndft <- data.frame(wt, retpt, sdpt)\ndft1 <- dft[dft$w1 == 1, ]\n\np <- ggplot() +\n  geom_point(data=df, aes(x=sdp, y=retp, color=ifelse(w1>1,\"red\" ,ifelse(w1<0,\"grey\",\"pink\"))), size=1, show.legend = FALSE) +\n            geom_point(data=dfrf1,aes(x=sdp1,y=retp1,color=ifelse(w1>1,'blue','lightblue')), size=1, show.legend = FALSE) +\n            geom_point(data=dft  ,aes(x=sdpt,y=retpt,color=ifelse(wt>1,'darkgreen','lightgreen')), size=1, show.legend = FALSE) +\n            geom_point(size=1)  +\n            labs(x = \"Standard deviation\",y='Expected return', title = \"Efficient frontier and the tanget portfolio\" ) +\n            xlim(0, max(sdp)) + ylim(0, max(retp) ) +\n            geom_text(data = d1, aes(x=sdp+0.015, y=retp-0.01, label = \"Asset 1\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = d2, aes(x=sdp+0.035, y=retp, label = \"Asset 2\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = dft, aes(x=sdp_t-0.04, y=retp_t, label = \"Tanget Port.\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +\n            geom_text(data = as.data.frame(rf), aes(x=0.02, y=rf-0.01, label = \"Risk-free\") , color = \"black\", hjust=-0.2, vjust=0.75, size=4) +            theme_solarized()+\n        scale_color_identity()\nggplotly(p)\n```\n\n\n\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\n\ncorr12 = -0.164\nret1 = 0.175\nsd1 = 0.258\nvar1 = sd1**2\nret2 = 0.055\nsd2 = 0.115\nvar2 = sd2**2\ncovar12 = corr12*sd1*sd2\nw1 = np.arange(-0.4, 1.41, 0.01)\nw2 = 1 - w1\nretp = w1*ret1 + w2*ret2\nvarp = w1**2 * var1 + w2**2 * var2 + 2*w1*w2*covar12\nsdp = np.sqrt(varp)\nport_names = [f\"portfolio {i+1}\" for i in range(len(w1))]\ndf = pd.DataFrame({'port.names': port_names, 'w1': w1, 'w2': w2, 'retp': retp, 'sdp': sdp})\nd1 = df[df['w1'] == 1]\nd2 = df[df['w2'] == 1]\ndf1 = df[['w1', 'retp', 'sdp']]\n\n# Including risk free rate\nrf = 0.03\nwrf1 = 1 - w1\nwrf2 = 1 - w2\nretp1 = wrf1 * rf + w1 * ret1\nsdp1 = w1*sd1\nretp2 = wrf2 * rf + w2 * ret2\nsdp2 = w2*sd2\ndfrf1 = np.column_stack((w1, retp1, sdp1))\n# Tangent portfolio\ntop = (ret1 - rf)*var2 - (ret2 - rf)*covar12\nbot = (ret1 - rf)*var2 + (ret2 - rf)*var1 - (ret1 - rf + ret2 - rf)*covar12\nw1_t = top/bot\nw2_t = 1 - w1_t\nretp_t = w1_t*ret1 + w2_t*ret2\nvarp_t = w1_t**2 * var1 + w2_t**2 * var2 + 2*w1_t*w2_t*covar12\nsdp_t = np.sqrt(varp_t)\ntan = (retp_t - rf)/sdp_t\ndft = np.column_stack((w1_t, retp_t, sdp_t))\n# exploding tangent line\nwt = np.arange(0, 2.01, 0.01)\nwrft = 1 - wt\nretpt = wrft * rf + wt * retp_t\nsdpt = wt*sdp_t\ndft = np.column_stack((wt, retpt, sdpt))\ndft1 = dft[dft[:, 0] == 1, :]\ndft = pd.DataFrame(dft)\ndft = {'wt': wt, 'retpt': retpt, 'sdpt': sdpt}\n\n#plot\nplt.close()\nfig, ax = plt.subplots()\nscatter1 = ax.scatter(df['sdp'], df['retp'], s=3, c=np.where(df['w1'] > 1, 'red', np.where(df['w1'] < 0, 'grey', 'pink')))\nscatter2 = ax.scatter(sdp1, retp1, s=3, c=np.where(df['w1'] > 1, 'blue', 'lightblue'))\nscatter3 = ax.scatter(dft['sdpt'], dft['retpt'], s=3, c=np.where(dft['wt']>1,'darkgreen','lightgreen'))\nplt.xlim(0, max(df['sdp']))\nplt.ylim(0, max(df['retp']))\nplt.xlabel('Standard deviation',fontsize=15)\nplt.ylabel('Expected return',fontsize=15)\nplt.title('Efficient frontier and the tanget portfolio',fontsize=20)\nax.text(0.005, 0.025, 'Risk-free', color='black', ha='left', va='center', fontsize=12)\nax.text(sd1+0.01,ret1, 'Asset 1', color='black', ha='left', va='center', fontsize=12)\nax.text(sd2+0.01,ret2, 'Asset 2', color='black', ha='left', va='center', fontsize=12)\nax.text(sdp_t-0.07,retp_t, 'Tangent Port.', color='black', ha='left', va='center', fontsize=12)\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nRemember that you can have **short positions**:\n\nIf you borrow at the Rf to invest in a portfolio, you have a levered position. \n\nYou are investing more than 100% of your funds in the portolio. The weight is higher than 1.\n\nThe book calls this **buying stocks on margin**.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\nTo identify the tangent portfolio, we compute the Sharpe ratio. \n\n$$Sharpe\\;ratio = \\frac{E[R_p]-R_f}{Sd(R_p)}$$\n\nTo earn the highest possible expected return for any level of volatility we must find the portfolio that generates the steepest (highest inclination) possible line when combined with the risk-free investment.\n\n. . .\n\nThe **optimal portfolio to combine with the risk-free asset will be the one with the highest Sharpe ratio**, where the line with the risk-free investment **just touches, and so is tangent** to, the efficient frontier of risky investments\n\n. . .\n\nThe Sharpe ratio measures the ratio of **reward-to-volatility** provided by a portfolio. \n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n**Fact 1:** The tangent portfolio is **efficient**.\n\n. . .\n\n**Fact 2:** Once we include the risk-free investment, all efficient portfolios are combinations of the risk-free investment and the tangent portfolio.\n\n. . .\n\nAll investors should have the tangent portfolio. All investors should combine the tangent portfolio with the risk free asset to adjust the level of risk.\n\n. . .\n\nIf you ignore the risk free asset, you have several efficient portfolios (**efficient frontier**). **But once you combine with the risk free rate, there is only one.** \n\n\n\n\n\n\n\n\n\n\n\n## 11.5 Risk-Free Saving and Borrowing {.smaller  background=\"#cff5ce\" }\n\n**What is a good Sharpe Ratio?**\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nport$rf <- 0.1\nport$sharpe <- (port$Return - port$rf) / port$Sd\np<-ggplot(port, aes(x=sharpe)) + \n        geom_histogram(alpha=0.2) + \n        theme_solarized() + \n        xlab(\"Sharpe\") + ylab(\"Number of portfolios\") + \n        labs(title = paste(int , \"random portfolios - All Ibov (2010-2023, yearly returns, Rf = 0.10)\") )\nggplotly(p)\n```\n\n\n### Python\n\n::: {.callout-important}\n\n**The following code uses monthly returns instead of annual.** \n\n:::\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nport['rf'] = 0.01 # using 1% of RF per month\nport['sharpe'] = (port['Return'] - port['rf']) / port['Sd']\n# Plot histogram\nplt.close()\nplt.hist(port['sharpe'], alpha=0.5)\nplt.xlabel('Sharpe',fontsize=15)\nplt.ylabel('Number of portfolios',fontsize=15)\nplt.title(str(int_) + ' random portfolios - All Ibov (2010-2023, monthly returns)' , fontsize=25)\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nLet's now consider how much **return we will demand from a risky asset** in order to make its inclusion in our portfolio worthy.\n\nLet's say that **you hold an arbitrary portfolio P** (it does not matter what is inside P for the moment).\n\nYou only include an additional asset if it **excess return to the level of risk**, right? That is, if it **increases the Sharpe ratio** of the resulting portfolio (Portfolio P + New asset)\n\n. . . \n\nWhat is the excess return that this asset *i* brings to your portfolio P?\n\n- $E[R_i] - R_f$ (quite simple!)\n\n. . .\n\nWhat is the risk that this asset *i* brings to your portfolio P?\n\n- It is $Sd(R_i) \\times corr(R_i,R_p)$\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nSo now our question is: **Is the gain in return from investing in *i* adequate to make up for the increase in risk?**\n\n. . .\n\nTo see that, we have to test if (because the right-hand part is the level of return-to-risk we already have in P). \n\n$$\\frac{E[R_i] - R_f}{Sd(R_i) \\times corr(R_i,R_p)} > \\frac{E[R_p] - R_f}{Sd(R_p)}$$\n\nMoving the denominator to the right-hand side:  \n\n$$E[R_i] - R_f > Sd(R_i) \\times corr(R_i,R_p) \\times \\frac{E[R_p] - R_f}{Sd(R_p)}$$\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nWhich is: \n\n$$E[R_i] - R_f > \\frac{Sd(R_i) \\times corr(R_i,R_p)}{Sd(R_p)}  \\times (E[R_p] - R_f)$$\n\n\nUsing a Beta notation:\n\n\n$$E[R_i] - R_f > \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\nThen:\n\n$$E[R_i]  >  R_f + \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nThat is, increasing the amount invested in i will increase the Sharpe ratio of portfolio P if its expected return $E[R_i]$ exceeds its required return given portfolio P, defined as\n\n$$R_i =  R_f + \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\nThe required return is the **expected return that is necessary to compensate for the risk investment i will contribute to the portfolio**. \n\n. . .\n\nThe required return for an investment *i* is equal to the **risk-free interest rate plus the risk premium of the current portfolio, P, scaled by *i*’s sensitivity to P, which is $\\beta_i^P$**. \n\nIf *i*’s expected return exceeds this required return, then adding more of it will improve the performance of the portfolio.\n\n\n\n\n\n\n\n\n\n\n## 11.6 Efficient Port. and Required Returns {.smaller background=\"#f2f5ce\"} \n\n**To emphasize** \n\nThis equation establishes the relation between an investment’s risk and its expected return.\n\nIt states that we can determine the appropriate risk premium for an investment from its beta with the efficient portfolio.\n\n$$R_i =  R_f + \\beta_i^P  \\times (E[R_p] - R_f)$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\nThis is perhaps the most important model in Finance.\n\n**Three main assumptions:**\n\n- **Investors can buy and sell all securities** at competitive market prices (**without incurring taxes or transactions costs**) and **can borrow and lend at the risk-free interest rate**. \n  \n- **Investors hold only efficient portfolios** of traded securities.\n\n- Investors have **homogeneous expectations** regarding the volatilities, correlations, and expected returns of securities. There is no information asymmetry. \n\n. . .\n\n**If investors have homogeneous expectations, they will identify the same efficient portfolio (the highest Sharpe).**\n\n**Under the CAPM assumptions, we can identify the efficient portfolio: It is equal to the market portfolio.**\n\nA Market portfolio contains all traded securities in a economy.\n\n\n\n\n\n\n\n\n\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\nIf investors identify the same market portfolio (the highest Sharpe), then we can identify the **Capital Market Line (CML)**. \n\nAll investors will have a combination of the Market Portfolio and the Rf rate.\n\n<img src=\"figs/bm_11_11.png\" width=\"90%\" />\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int ,  \"random portfolios - All Ibov (2010-2023, yearly returns)\") ) + \n        geom_abline(intercept = 0.1, slope = max(port$sharpe), color=\"red\", size=1) +\n        xlim(0, 0.4) + ylim(0.075, 0.25) +   theme_solarized()\nggplotly(p)\n```\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nplt.close()\nplt.figure(figsize=(20,10))\nplt.scatter(port['Sd'], port['Return'], alpha=0.5, color=\"darkblue\", s=50)\nplt.xlabel('Standard deviation', fontsize=25)\nplt.ylabel('Expected Return', fontsize=25)\nplt.title(str(int_) + ' random portfolios - All Ibov (2010-2023, monthly returns)' , fontsize=25)\nplt.xlim(0, 0.02+max(port['Sd']))\nplt.ylim(0, 0.02+max(port['Return']))\nax.tick_params(axis='both', which='major', labelsize=14)\nplt.plot([0, 0.75], [port['rf'].iloc[0], port['sharpe'].max()], color='red')\nplt.show()\n```\n\n\n:::\n\n\n\n\n\n\n\n## 11.7 The CAPM {.smaller background=\"#c9f7ba\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        theme_solarized() + \n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int ,  \"random portfolios - All Ibov (2010-2023, yearly returns)\") ) + \n        geom_abline(intercept = max(port$rf), slope = max(port$sharpe), color=\"red\", size=1)\nggplotly(p)\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n**Under the CAPM assumptions, we can identify the efficient portfolio: It is equal to the market portfolio.**\n\nThus, we can change $R_p$ to $R_m$\n\n$$E[R_i] =  R_f + \\beta_i  \\times (E[R_m] - R_f)$$\n\nThe beta of a security measures its volatility due to market risk relative to the market as a whole, and thus captures the security’s sensitivity to market risk.\n\n**This is the CAPM!**\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\nList of Betas of Brazilian Companies.\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nstart <-'2018-06-01' \nend   <- Sys.Date()\nfreq_data <-  'monthly'\nibov <- yf_get(tickers = \"^BVSP\",\n                        first_date = start,\n                        last_date = end,\n                        thresh_bad_data = 0.5,\n                        freq_data = freq_data )\nasset <- yf_collection_get(\"IBOV\", \n                         first_date = start,\n                         last_date = end,\n                         thresh_bad_data = 0.5,\n                         freq_data = freq_data )\nret_ibov <- ibov  %>%tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'monthly',\n                                  col_rename = 'return')\nret_asset <- asset %>%    \n            group_by(ticker) %>%\n            tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'monthly',\n                                  col_rename = 'return')\nret <- left_join(ret_ibov, ret_asset, by = c(\"ref_date\" = \"ref_date\"))\n#To compute beta\nvar <- ret %>% group_by(ticker) %>% summarise(var = var(return.x, return.x)) # Computing the variance of the market\ncov <- ret %>% group_by(ticker) %>% summarise(cov = cov(return.x, return.y))\nbeta <- merge(cov, var, by =\"ticker\" )\nbeta$beta <- beta$cov/beta$var\n# Risk free rate\nbeta$rf  <- 0.1 \n# Equity risk premium from here: https://ceqef.fgv.br/node/594\nbeta$erp <- 0.16 \n# expected return\nbeta$ep <- beta$rf + beta$beta * beta$erp\np<-ggplot(beta, aes(x = reorder(ticker, beta ), y = beta, fill=beta) ) +\n  geom_bar(aes(fill = -beta), position = \"dodge\", stat=\"identity\")+\n  theme(legend.position=\"none\", \n        axis.text.y = element_blank() )+\n  coord_flip()+\n  labs(y = \"Beta\", x = \"Stocks\", title = \"Betas Brazilian companies, monthly data (2018-2023)\") +   theme_solarized()\nggplotly(p)\n```\n\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: true\nstart = '2018-06-01'\nend = '2023-01-01'\nfreq_data = '1mo'\nibov_tickers = [\"ABEV3.SA\",\"ALPA4.SA\",\"AMER3.SA\",\"B3SA3.SA\",\"BBAS3.SA\",\"BBDC3.SA\",\"BBDC4.SA\",\"BEEF3.SA\",\"BPAN4.SA\",\"BRAP4.SA\",\"BRFS3.SA\",\"BRKM5.SA\",\"BRML3.SA\",\"CCRO3.SA\",\"CIEL3.SA\",\"CMIG4.SA\",\"COGN3.SA\",\"CPFE3.SA\",\"CPLE6.SA\",\"CSAN3.SA\",\"CSNA3.SA\",\"CYRE3.SA\",\"DXCO3.SA\",\"ECOR3.SA\",\"EGIE3.SA\",\"ELET3.SA\",\"ELET6.SA\",\"EMBR3.SA\",\"ENBR3.SA\",\"ENEV3.SA\",\"ENGI11.SA\",\"EQTL3.SA\",\"EZTC3.SA\",\"FLRY3.SA\",\"GGBR4.SA\",\"GOAU4.SA\",\"GOLL4.SA\",\"HYPE3.SA\",\"ITSA4.SA\",\"ITUB4.SA\",\"JBSS3.SA\",\"JHSF3.SA\",\"LREN3.SA\",\"MGLU3.SA\",\"MRFG3.SA\",\"MRVE3.SA\",\"MULT3.SA\",\"PCAR3.SA\",\"PETR3.SA\",\"PETR4.SA\",\"PRIO3.SA\",\"QUAL3.SA\",\"RADL3.SA\",\"RENT3.SA\",\"SANB11.SA\",\"SBSP3.SA\",\"SULA11.SA\",\"SUZB3.SA\",\"TAEE11.SA\",\"TIMS3.SA\",\"TOTS3.SA\",  \"UGPA3.SA\",\"USIM5.SA\",\"VALE3.SA\",\"VIIA3.SA\",\"VIVT3.SA\",\"WEGE3.SA\",\"YDUQ3.SA\"]\n\nibov = yf.download(tickers=\"^BVSP\", start=start, end=end, interval=freq_data)\nasset = yf.download(tickers=ibov_tickers   ,start=start, end=end, interval=freq_data)\n\nret_ibov = pd.DataFrame(ibov['Adj Close'].pct_change().dropna())\nret_ibov.columns = ['return']\n\nret_asset = pd.DataFrame()\nfor col in asset.columns.get_level_values(1).unique():\n    temp_df = pd.DataFrame(asset['Adj Close'][col].pct_change().dropna())\n    temp_df.columns = ['return']\n    temp_df['ticker'] = col.split('.')[0]\n    ret_asset = pd.concat([ret_asset, temp_df], axis=0)\nret = pd.merge(ret_ibov, ret_asset, on='Date')\n# To compute beta\nvar = pd.DataFrame(ret.groupby('ticker')['return_x'].var())\nvar = var.rename(columns={\"return_x\": \"variance\"})\ncov = ret.groupby('ticker')['return_x', 'return_y'].cov().iloc[0::2, 1]\nbeta = pd.merge(var, cov, on='ticker')\nbeta.reset_index(inplace=True)\nbeta.rename(columns={\"return_y\": \"covariance\", \"return_x\": \"variance\", \"ticker\": \"Ticker\"}, inplace=True)\nbeta = beta[['Ticker', 'variance', 'covariance']]\nbeta.head()\nbeta['beta'] = beta['covariance'] / beta['variance']\n# Risk free rate\nbeta['rf'] = 0.1\n# Equity risk premium from here: https://ceqef.fgv.br/node/594\nbeta['erp'] = 0.16\n# expected return\nbeta['ep'] = beta['rf'] + beta['beta'] * beta['erp']\n\nplt.close()\nplt.figure(figsize=(20,10))\nbeta = beta.sort_values('beta', ascending=True)\nfig, ax = plt.subplots(figsize=(20,10))\nax.barh(beta['Ticker'], beta['beta'], color='#268bd2')\nax.set_title('Betas Brazilian companies, monthly data (2018-2023)', fontsize=25)\nax.set_xlabel('Beta', fontsize=20)\nax.set_ylabel('Ticker', fontsize=20)\nplt.xticks(rotation=90, fontsize=7)\nplt.tight_layout()\nax.tick_params(axis='x', labelsize=14)\nplt.show()\n\n```\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n**The Security Market Line**\n\nThe CAPM implies there is a linear relationship between a stock's Beta and its expected return.\n\nThis linear relationship has a name: **Security Market Line (SML)**\n\n\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n![](figs/bm_11_12.png){width=\"90%\"}\n\n\n\n\n\n\n\n\n\n## 11.8 Determining the Risk Premium {.smaller background=\"#FFFA9A\"}\n\n::: {.panel-tabset}\n\n### R\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\n#Security Market Line\np<-ggplot(data=beta, aes(x = beta, y = ep  )  ) + geom_point() +\nggrepel::geom_text_repel(data=beta, aes(label = ticker) , size = 2.5 ,  max.overlaps = Inf)+\n  theme(legend.position=\"none\",  axis.text.y = element_blank() )+\n  labs(y = \"Expected return\", \n       x = \"Beta\", \n       title = \"SML Brazil, monthly data (2018-2023)\" , \n       subtitle = \"Rf = 10% per year, Risk premium = 16%\" )+   theme_solarized()\np\n```\n\n\n\n### Python\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nplt.close()\nplt.figure(figsize=(10,6))\nplt.scatter(beta['beta'], beta['ep'], c='#268bd2', alpha=0.7, s=8)\nplt.ylabel('Expected Return', fontsize=20)\nplt.xlabel('Beta', fontsize=20)\nplt.title('SML Brazil, monthly data (2018-2023)', fontsize=20)\nplt.suptitle('Rf = 10% per year, Risk premium = 16%', fontsize=15)\nplt.show()\n```\n\n:::\n\n\n\n\n\n\n\n\n\n\n# Questions and Final comments {.smaller background=\"#34B3B9\"}\n\n## Question {.smaller background=\"#34B3B9\"}\n\nImagine that you find the SML in the economy, and you find that two assets lies below it. **Would you buy these assets?**\n\n<img src=\"figs/bre13901_0807.jpg\" width=\"100%\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Question {.smaller background=\"#34B3B9\"}\n\n**Both assets are expensive.** They are offering less return than they are expected to offer according to the CAPM.\n\nBecause they are expensive, **investors are expected to sell them. So prices are expected to drop.**\n\n\n\n\n\n\n\n\n\n## Final comments I {.smaller background=\"#61D5DA\"}\n\n**The beta of a portfolio is the weighted average beta of the assets in the portfolio.**\n\n$$\\beta_p = \\sum_i x_i \\times \\beta_i$$\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Final comments II {.smaller background=\"#61D5DA\"}\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\nfreq.data   <- 'daily'\nstart <-'2000-01-01' \nend   <-Sys.Date() \nibov <- yf_get(tickers = \"^BVSP\",\n                        first_date = start,\n                        last_date = end,\n                        thresh_bad_data = 0.5,\n                        freq_data = freq.data )\nasset <- yf_get(tickers = \"WEGE3.SA\",\n                        first_date = start,\n                        last_date = end,\n                        thresh_bad_data = 0.5,\n                        freq_data = freq.data )\nret_ibov <- ibov  %>%tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'daily',\n                                  col_rename = 'return',\n                                  type = 'log')\nret_asset <- asset %>%tq_transmute(select = price_adjusted,\n                                  mutate_fun = periodReturn,\n                                  period = 'daily',\n                                  col_rename = 'return',\n                                  type = 'log')\nret <- left_join(ret_ibov, ret_asset, by = c(\"ref_date\" = \"ref_date\"))\nwindow <-252\nret$var <- roll_cov(ret$return.x, ret$return.x, width = window)\nret$cov <- roll_cov(ret$return.x, ret$return.y, width = window)\nret$beta <- ret$cov / ret$var\nret <- subset(ret, ret$beta != \"NA\" )\n\nbweg<- ggplot(ret, aes(x= return.x, y=return.y)) + \n  geom_point()+\n  geom_smooth(method=lm, se=FALSE)+\n  labs( y = \"Daily returns WEGE3\", x=\"Daily returns IBOV\",title = \"Beta WEGE3\")+\n  theme(plot.title = element_text(color=\"darkgreen\", size=18, face=\"bold\"),\n        panel.background = element_rect(fill = \"grey95\", colour = \"grey95\"),\n        axis.title=element_text(size=12,face=\"bold\"),\n        title=element_text(size=10,face=\"bold\", color=\"darkgreen\"),\n        axis.text.y = element_text(face = \"bold\", color = \"darkgreen\", size = 12),\n        axis.text.x = element_text(face = \"bold\", color = \"darkgreen\", size = 12))+\n  xlim(-0.2, 0.2) + ylim(-0.2, 0.2) +   theme_solarized()\n\np<-ret %>%\n    ggplot(aes(x = ref_date, y = beta)) +\n    labs( y = \"\", x=\"\",title = \"Beta WEGE3 through time\")+\n    geom_line()+   theme_solarized()  + transition_reveal(ref_date) \n#ggplotly(p)\nanimate(p, fps = 10, duration = 10)\n```\n\n\n\n## Final comments II {.smaller background=\"#61D5DA\" visibility=\"hidden\"}\n\n```{python}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| results: false\n#| output: true\n#| code-fold: true\n#| code-line-numbers: true\t\n#| output-location: default\n#| code-summary: \"Python\"\n#| collapse: true\n#| eval: false\nfreq_data = '1d'\nstart = '2000-01-01'\nend = pd.Timestamp.now()\nibov = yf.download('^BVSP', start=start, end=end, interval=freq_data)\nasset = yf.download('WEGE3.SA', start=start, end=end, interval=freq_data)\nret_ibov = np.log(ibov['Adj Close']).diff()\nret_asset = np.log(asset['Adj Close']).diff()\nret = pd.concat([ret_ibov, ret_asset], axis=1).dropna()\nwindow = 252\nvar = ret.iloc[:, 0].rolling(window).cov(ret.iloc[:, 0])\ncov = ret.iloc[:, 0].rolling(window).cov(ret.iloc[:, 1])\nbeta = cov / var\nret['beta'] = beta.values\nret.dropna(inplace=True)\nplt.close()\nplt.figure(figsize=(20, 10))\nplt.plot(ret.index, ret['beta'],c='#268bd2')\nplt.title('Beta WEGE3 through time', fontsize=25)\nplt.xlabel('Time', fontsize=18)\nplt.ylabel('Beta', fontsize=18)\nax.tick_params(axis='both', which='major', labelsize=18)\nplt.show()\n```\n\n\n\n\n\n\n\n\n\n\n\n## Final comments III {.smaller background=\"#61D5DA\"}\n\n```{r}\n#| warning: false\n#| message: false\n#| fig-align: center\n#| echo: true\n#| output-location: default\n#| code-fold: true\n#| code-summary: \"R\"\n#| code-line-numbers: true\n#| eval: true\n# rf = 3%\nport1 <- port\nport1$rf <- 0.03\nport1$sharpe <- (port1$Return - port1$rf) / port1$Sd\n# rf = 7.5%\nport2 <- port\nport2$rf <- 0.075\nport2$sharpe <- (port2$Return - port2$rf) / port2$Sd\n# rf = 15%\nport3 <- port\nport3$rf <- 0.15\nport3$sharpe <- (port3$Return - port3$rf) / port3$Sd\n#ggplot\np<-ggplot(port, aes(x=Sd, y=Return)) +\n        geom_point(alpha=0.2) +\n        xlab(\"Standard deviation\") + ylab(\"Expected Return\") + \n        labs(title = paste(int ,  \"random portfolios - All Ibov (2010-2023, yearly returns)\") ) + \n        geom_abline(intercept = max(port$rf) , slope = max(port$sharpe) , color=\"red\",  size=1)  +\n        geom_abline(intercept = max(port1$rf), slope = max(port1$sharpe), color=\"blue\", size=1) +\n        geom_abline(intercept = max(port2$rf), slope = max(port2$sharpe), color=\"green\", size=1) +\n        geom_abline(intercept = max(port3$rf), slope = max(port3$sharpe), color=\"orange\", size=1) +\n        xlim(0, 0.4) + ylim(0, 0.25) +   theme_solarized() +\n        geom_text( aes(x=0, y= max(port$rf)-0.02 , label = \"Rf = 10%\") , color = \"red\", hjust=-0.2, vjust=0.75, size=3.5) +\n        geom_text( aes(x=0, y= max(port1$rf)-0.02, label = \"Rf = 3%\") , color = \"blue\", hjust=-0.2, vjust=0.75, size=3.5)  +\n        geom_text( aes(x=0, y= max(port2$rf)-0.02, label = \"Rf = 7.5%\") , color = \"green\", hjust=-0.2, vjust=0.75, size=3.5)+\n        geom_text( aes(x=0, y= max(port3$rf)-0.02, label = \"Rf = 15%\") , color = \"orange\", hjust=-0.2, vjust=0.75, size=3.5)\nggplotly(p)\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#  Recap {.smaller visibility=\"hidden\"}\n\n##  Recap {.smaller visibility=\"hidden\"}\n\n**After this chapter, you should know:**\n\n- Compute the variance of an equally weighted portfolio \n\n- Describe the contribution of each security to the portfolio.\n\n- Explain how an individual investor will choose from the set of efficient portfolios. Explain what is an efficient portfolio.\n\n- Describe what is meanHenrique C. Martins' Zoom Meetingt by a short sale, and illustrate how short selling extends the set of possible portfolios.\n\n- Explain the effect of combining a risk-free asset with a portfolio of risky assets, and compute the expected return and volatility for that combination.\n\n- Define the Sharpe ratio, and explain how it helps identify the portfolio with the highest possible expected return for any level of volatility, and how this information can be used to identify the tangency (efficient) portfolio.\n\n- Calculate the beta of an investment with a portfolio.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##  Recap {.smaller visibility=\"hidden\"}\n\n**After this chapter, you should know:**\n\n- Use the beta of a security, expected return on a portfolio, and the risk-free rate to decide whether buying shares of that security will improve the performance of the portfolio.\n\n- Use the risk-free rate, the expected return on the efficient (tangency) portfolio, and the beta of a security with the efficient portfolio to calculate the risk premium for an investment.\n\n- Explain why the CAPM implies that the market portfolio of all risky securities is the efficient portfolio.\n\n- Compare and contrast the capital market line with the security market line.\n\n- Define beta for an individual stock and for a portfolio.\n\n\n\n\n\n\n\n\n\n\n\n# Comments? {background=\"#a2bef5\" visibility=\"hidden\"}\n\n## Comments? {background=\"#a2bef5\"}\n\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"henriquecastror/efcomments-part-3\"\n        data-repo-id=\"R_kgDOK8BQMg\"\n        data-category-id=\"DIC_kwDOK8BQMs4Cb463\"\n        data-mapping=\"pathname\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"bottom\"\n        data-theme=\"light\"\n        data-lang=\"en\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n\n\n\n\n\n\n\n## **THANK YOU!** {background=\"#b1cafa\"}\n\n::: columns\n\n::: {.column width=\"60%\"}\n\n**QUESTIONS?**\n\n![](figs/qa2.png){width=150% heigth=150%}\n:::\n::: {.column width=\"40%\"}\n**Henrique C. Martins**\n\n-   [FGV/EAESP](https://eaesp.fgv.br/en/people/henrique-castro-martins)\n-   [Personal Website](https://henriquemartins.net/)\n-   [LinkedIn](https://www.linkedin.com/in/henriquecastror/)\n-   [Lattes](http://lattes.cnpq.br/6076997472159785)\n-   [Scholar](https://scholar.google.com.br/citations?user=7gIfkRMAAAAJ&hl=pt-BR&oi=ao)  \n:::\n:::\n\n::: footer\n:::\n\n\n\n\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","css":["logo.css"],"output-file":"part_3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.3.450","auto-stretch":true,"editor":"visual","title":"Estratégia Financeira","subtitle":" **Part 3 - ch.11 Optimal Portfolio Choice and the Capital Asset Pricing Model** ","author":[{"name":" **Henrique C. Martins** ","affiliation":"**[![](figs/background6.png){width=300px}](https://eaesp.fgv.br/en)**"}],"date":"last-modified","date-format":"DD-MM-YYYY","title-block-banner":true,"title-slide-attributes":{"data-background-color":"#b1cafa"},"include-after":["<script type=\"text/javascript\">\n  Reveal.on('ready', event => {\n    if (event.indexh === 0) {\n      document.querySelector(\"div.has-logo > img.slide-logo\").style.display = \"none\";\n    }\n  });\n  Reveal.addEventListener('slidechanged', (event) => {\n    if (event.indexh === 0) {\n      Reveal.configure({ slideNumber: null });\n      document.querySelector(\"div.has-logo > img.slide-logo\").style.display = \"none\";\n    }\n    if (event.indexh === 1) {\n      Reveal.configure({ slideNumber: 'c' });\n      document.querySelector(\"div.has-logo > img.slide-logo\").style.display = null;\n    }\n  });\n</script>\n"],"slideNumber":true,"theme":"simple","chalkboard":true,"previewLinks":"auto","logo":"figs/background8.png","footer":" **[**Henrique C. Martins**] [[henrique.martins@fgv.br](mailto:henrique.martins@fgv.br)] [[Teaching Resources](https://henriquemartins.net/teaching/)] [[Comments](https://henriquemartins.net/teaching/financial_strategy/part_3.html#/comments)]** ","multiplex":true,"scrollable":true}}},"projectFormats":["html","revealjs"]}